<!DOCTYPE html>
<html lang="zh-Hant" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>å¯¦é©—åˆ†æèˆ‡ç™¼ç¾ç·´ç¿’å·¥å…·</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* ä½¿ç”¨ Google Fonts çš„ Noto Sans TC å­—é«” */
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&display=swap');
        html, body {
            font-family: 'Noto Sans TC', sans-serif;
            background-color: #f0f2f5;
            overflow: hidden; /* ç¦ç”¨é é¢ä¸»æ»¾å‹•æ¢ */
        }
        /* è‡ªè¨‚æ¨£å¼ */
        .group-active-radio:checked { background-color: #2563eb; border-color: #2563eb; }
        .color-input::-webkit-color-swatch-wrapper { padding: 0; }
        .color-input::-webkit-color-swatch { border: none; border-radius: 50%; }
        canvas { cursor: crosshair; touch-action: none; } /* touch-action: none é˜²æ­¢è§¸æ§æ™‚çš„æ»¾å‹•ç­‰é è¨­è¡Œç‚º */
        .canvas-bg-white { background-color: white; }
        /* ç¾åŒ–æ»¾å‹•æ¢ */
        .custom-scrollbar::-webkit-scrollbar { width: 8px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 10px; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #c7c7c7; border-radius: 10px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #a8a8a8; }
    </style>
</head>
<body class="h-full text-gray-800">

    <!-- å…¨è¢å¹•ä½ˆå±€å®¹å™¨ -->
    <div class="h-screen flex flex-col p-4 lg:p-6 gap-4">
        <!-- æ‡‰ç”¨ç¨‹å¼æ¨™é¡Œ (å›ºå®šé«˜åº¦) -->
        <header class="text-center flex-shrink-0">
            <h1 class="text-3xl lg:text-4xl font-bold text-gray-700">å¯¦é©—æ•¸æ“šçµ±è¨ˆåœ–ç¹ªè£½å·¥å…·</h1>
        </header>

        <!-- ä¸»å…§å®¹å€ (å¡«æ»¿å‰©é¤˜ç©ºé–“) -->
        <main class="flex-grow grid grid-cols-1 lg:grid-cols-8 gap-6 overflow-hidden">

            <!-- å·¦å´ï¼šåœ–è¡¨èˆ‡åŠŸèƒ½å€ (å›ºå®šä¸æ»¾å‹•) -->
            <div class="lg:col-span-5 flex flex-col h-full">
                <div class="bg-white p-4 rounded-xl shadow-lg h-full flex flex-col">
                    <!-- ç•«å¸ƒå®¹å™¨ (è‡ªå‹•ä¼¸å±•) -->
                    <div class="relative w-full flex-grow">
                        <canvas id="chart-canvas" class="absolute top-0 left-0 w-full h-full rounded-lg border border-gray-300 canvas-bg-white"></canvas>
                    </div>
                </div>
            </div>
            
            <!-- å³å´ï¼šè¨­å®šèˆ‡æ•¸æ“šé¢æ¿ (å…§éƒ¨å¯æ»¾å‹•) -->
            <div class="lg:col-span-3 space-y-6 overflow-y-auto custom-scrollbar pr-3">
                <!-- è¨­å®šé¢æ¿ -->
                <div class="bg-white p-5 rounded-xl shadow-lg">
                    <h2 class="text-xl font-bold mb-4 border-b pb-2">ä¸€ã€åœ–è¡¨è¨­å®š</h2>
                    
                    <div class="space-y-4 mb-6">
                        <div>
                              <h3 class="text-lg font-semibold text-gray-700">1.å¡«å…¥é©ç•¶çš„åœ–è¡¨æ¨™é¡Œ</h3>
                            <input type="text" id="chart-title" value="åœ–è¡¨æ¨™é¡Œ" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50">
                        </div>
                    </div>

                    <div class="space-y-4 mb-6">
                        <h3 class="text-lg font-semibold text-gray-700">2.è¨­å®šæ“ç¸±è®Šå› (å–®ä½)ï¼Œåˆ»åº¦ç¯„åœå’Œæ¯æ ¼å–®ä½</h3>
                        <div>
                            <label for="x-axis-label" class="block text-sm font-medium text-gray-600">è¨­å®šæ©«è»¸</label>
                            <input type="text" id="x-axis-label" value="æ“ä½œè®Šå› (å–®ä½)" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50">
                        </div>
                        <div class="grid grid-cols-2 gap-4">
                            <div>
                                <label for="x-axis-min" class="block text-sm font-medium text-gray-600">æœ€å°å€¼</label>
                                <input type="number" id="x-axis-min" value="0" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50">
                            </div>
                            <div>
                                <label for="x-axis-max" class="block text-sm font-medium text-gray-600">æœ€å¤§å€¼</label>
                                <input type="number" id="x-axis-max" value="100" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50">
                            </div>
                        </div>
                        <div>
                            <label for="x-axis-unit" class="block text-sm font-medium text-gray-600">æ¯æ ¼å–®ä½</label>
                            <input type="number" id="x-axis-unit" value="10" min="0.5" step="0.5" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50">
                        </div>
                    </div>

                    <div class="space-y-4 mb-6">
                        <h3 class="text-lg font-semibold text-gray-700">3.è¨­å®šæ‡‰è®Šè®Šå› (å–®ä½)ï¼Œåˆ»åº¦ç¯„åœå’Œæ¯æ ¼å–®ä½</h3>
                        <div>
                            <label for="y-axis-label" class="block text-sm font-medium text-gray-600">è¨­å®šç¸±è»¸</label>
                            <input type="text" id="y-axis-label" value="æ‡‰è®Šè®Šå› (å–®ä½)" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50">
                        </div>
                         <div class="grid grid-cols-2 gap-4">
                            <div>
                                <label for="y-axis-min" class="block text-sm font-medium text-gray-600">æœ€å°å€¼</label>
                                <input type="number" id="y-axis-min" value="0" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50">
                            </div>
                            <div>
                                <label for="y-axis-max" class="block text-sm font-medium text-gray-600">æœ€å¤§å€¼</label>
                                <input type="number" id="y-axis-max" value="50" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50">
                            </div>
                        </div>
                        <div>
                            <label for="y-axis-unit" class="block text-sm font-medium text-gray-600">æ¯æ ¼å–®ä½</label>
                            <input type="number" id="y-axis-unit" value="5" min="0.5" step="0.5" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50">
                        </div>
                    </div>
                    <button id="apply-settings" class="w-full bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 transition-colors mt-4">å¥—ç”¨è¨­å®š(æœƒæ¸…ç©ºæ•¸æ“š)</button>
                </div>

                <div class="bg-white p-5 rounded-xl shadow-lg">
                    <h2 class="text-xl font-bold mb-4 border-b pb-2">äºŒã€æ•¸æ“šæ“ä½œ</h2>
                    <div id="groups-container" class="space-y-3">
                        <!-- JavaScript æœƒåœ¨é€™è£¡å‹•æ…‹ç”Ÿæˆ 4 çµ„è¨­å®š -->
                    </div>
                    <div class="mt-4 bg-gray-50 p-3 rounded-lg">
                        <label for="show-labels-toggle" class="flex items-center justify-between cursor-pointer">
                            <span class="font-semibold text-gray-700">é¡¯ç¤ºæ•¸æ“šæ¨™ç±¤</span>
                            <div class="relative inline-flex items-center">
                                <input type="checkbox" id="show-labels-toggle" class="sr-only peer">
                                <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                            </div>
                        </label>
                    </div>
                    <div class="mt-6 space-y-3">
                        <button id="download-chart" class="w-full bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700 transition-colors">ä¸‹è¼‰åœ–è¡¨ (PNG)</button>
                        <button id="download-data" class="w-full bg-orange-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-orange-600 transition-colors">ä¸‹è¼‰æ•¸æ“š (CSV)</button>
                    </div>
                </div>
                
                <div class="bg-white p-5 rounded-xl shadow-lg">
                    <h2 class="text-xl font-bold mb-4 border-b pb-2">ä¸‰ã€æ’°å¯«å¯¦é©—çµæœ</h2>
                    <div class="space-y-4">
                        <div class="flex justify-between items-center">
                            <p class="text-sm text-gray-600">è«‹æ ¹æ“šä¸Šæ–¹çš„åœ–è¡¨ï¼Œæè¿°ä½ è§€å¯Ÿåˆ°çš„è¶¨å‹¢èˆ‡çµè«–ã€‚</p>
                            <button id="show-hint-btn" title="å¯«ä½œå°æç¤º" class="text-xl p-1 rounded-full hover:bg-gray-200 transition-colors">ğŸ’¡</button>
                        </div>
                        <textarea id="student-analysis" rows="6" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50" placeholder="ä¾‹å¦‚ï¼šç”±åœ–å¯çŸ¥ï¼Œç•¶...å¢åŠ æ™‚ï¼Œ...ä¹Ÿéš¨ä¹‹å¢åŠ ..."></textarea>
                        <button id="submit-for-feedback" class="w-full bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 transition-colors disabled:bg-indigo-400">
                            æäº¤çµ¦ AI è€å¸«åˆ†æ
                        </button>
                        <div id="ai-feedback-container" class="mt-4 p-4 bg-indigo-50 border-l-4 border-indigo-400 rounded-r-lg" style="display: none;">
                            <h4 class="font-bold text-indigo-800">AI è€å¸«çš„å›é¥‹ï¼š</h4>
                            <p id="ai-feedback-text" class="text-indigo-700 mt-2 whitespace-pre-wrap"></p>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- æ–°å¢ï¼šå¯«ä½œæç¤º Modal -->
    <div id="hint-modal" class="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center p-4 z-50" style="display: none;">
        <div class="bg-white rounded-2xl shadow-xl p-6 lg:p-8 max-w-lg w-full relative transform transition-all duration-300 scale-95 opacity-0" id="hint-modal-content">
            <button id="close-hint-modal" class="absolute top-3 right-3 text-2xl text-gray-400 hover:text-gray-800 transition-colors leading-none">&times;</button>
            <div class="flex items-center mb-4">
                <span class="text-3xl mr-3">ğŸ’¡</span>
                <h3 class="text-2xl font-bold text-gray-800">å¯«ä½œå°æç¤º</h3>
            </div>
            <div class="space-y-3 text-gray-700">
                <p>ä¸€ç¯‡å¥½çš„å¯¦é©—çµæœåˆ†æï¼Œé€šå¸¸åŒ…å«ä»¥ä¸‹å¹¾å€‹éƒ¨åˆ†ï¼Œä½ å¯ä»¥è©¦è‘—å›ç­”çœ‹çœ‹ï¼š</p>
                <ol class="list-decimal list-inside space-y-2 pl-2">
                    <li><strong>æè¿°é—œä¿‚</strong>ï¼šæ•´é«”ä¾†çœ‹ï¼Œç•¶ X è»¸çš„æ•¸å€¼è®Šå¤§æ™‚ï¼ŒY è»¸çš„æ•¸å€¼æ˜¯è·Ÿè‘—è®Šå¤§ã€è®Šå°ï¼Œé‚„æ˜¯æ²’æœ‰æ˜é¡¯é—œä¿‚å‘¢ï¼Ÿ</li>
                    <li><strong>å¼•ç”¨æ•¸æ“š</strong>ï¼šä½ å¯ä»¥å¾åœ–è¡¨ä¸­èˆ‰ä¸€å€‹å¯¦éš›çš„ä¾‹å­ä¾†æ”¯æŒä½ çš„èªªæ³•å—ï¼Ÿï¼ˆä¾‹å¦‚ï¼šç•¶æº«åº¦å¾ 20Â°C ä¸Šå‡åˆ° 60Â°C æ™‚ï¼Œæº¶è§£åº¦å¾ 15g ä¸Šå‡åˆ°äº† 45gã€‚ï¼‰</li>
                    <li><strong>æ¯”è¼ƒçµ„åˆ¥ (å¦‚æœé©ç”¨)</strong>ï¼šå¦‚æœåœ–è¡¨ä¸­æœ‰ä¸åŒçµ„åˆ¥ï¼Œå®ƒå€‘çš„æ•¸æ“šè¶¨å‹¢æœ‰ä»€éº¼ç›¸åŒæˆ–ä¸åŒçš„åœ°æ–¹ï¼Ÿå“ªä¸€çµ„çš„è®ŠåŒ–æ¯”è¼ƒå¿«ï¼Ÿ</li>
                    <li><strong>æå‡ºçµè«–</strong>ï¼šç¶œåˆä»¥ä¸Šè§€å¯Ÿï¼Œä½ å¯ä»¥å¾—åˆ°ä»€éº¼åˆæ­¥çš„çµè«–ï¼Ÿï¼ˆä¾‹å¦‚ï¼šæˆ‘èªç‚º X å’Œ Y ä¹‹é–“å¯èƒ½å­˜åœ¨æ­£æ¯”é—œä¿‚ã€‚ï¼‰</li>
                </ol>
            </div>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM å…ƒç´  ---
            const canvas = document.getElementById('chart-canvas');
            const ctx = canvas.getContext('2d');
            const chartTitleInput = document.getElementById('chart-title');
            const xAxisLabelInput = document.getElementById('x-axis-label');
            const xAxisMinInput = document.getElementById('x-axis-min');
            const xAxisMaxInput = document.getElementById('x-axis-max');
            const xAxisUnitInput = document.getElementById('x-axis-unit');
            const yAxisLabelInput = document.getElementById('y-axis-label');
            const yAxisMinInput = document.getElementById('y-axis-min');
            const yAxisMaxInput = document.getElementById('y-axis-max');
            const yAxisUnitInput = document.getElementById('y-axis-unit');
            const groupsContainer = document.getElementById('groups-container');
            const applyBtn = document.getElementById('apply-settings');
            const downloadBtn = document.getElementById('download-chart');
            const downloadDataBtn = document.getElementById('download-data');
            const showLabelsToggle = document.getElementById('show-labels-toggle');
            // AI & Hint åŠŸèƒ½ç›¸é—œ DOM
            const studentAnalysisInput = document.getElementById('student-analysis');
            const submitForFeedbackBtn = document.getElementById('submit-for-feedback');
            const aiFeedbackContainer = document.getElementById('ai-feedback-container');
            const aiFeedbackText = document.getElementById('ai-feedback-text');
            const showHintBtn = document.getElementById('show-hint-btn');
            const hintModal = document.getElementById('hint-modal');
            const hintModalContent = document.getElementById('hint-modal-content');
            const closeHintModalBtn = document.getElementById('close-hint-modal');

            // --- åˆå§‹è¨­å®šèˆ‡ç‹€æ…‹ ---
            const MAX_GROUPS = 4;
            const defaultGroupSettings = [
                { name: 'å¯¦é©— A', color: '#3b82f6', shape: 'circle', enabled: true, trendline: { visible: false, m: 0, b: 0, r2: 0, forceOrigin: false, showEquation: false, equationPos: { x: null, y: null }, equationBBox: null } },
                { name: 'å¯¦é©— B', color: '#ef4444', shape: 'square', enabled: false, trendline: { visible: false, m: 0, b: 0, r2: 0, forceOrigin: false, showEquation: false, equationPos: { x: null, y: null }, equationBBox: null } },
                { name: 'å¯¦é©— C', color: '#22c55e', shape: 'triangle', enabled: false, trendline: { visible: false, m: 0, b: 0, r2: 0, forceOrigin: false, showEquation: false, equationPos: { x: null, y: null }, equationBBox: null } },
                { name: 'å¯¦é©— D', color: '#f97316', shape: 'cross', enabled: false, trendline: { visible: false, m: 0, b: 0, r2: 0, forceOrigin: false, showEquation: false, equationPos: { x: null, y: null }, equationBBox: null } }
            ];

            let chartState = {
                title: 'å¯¦é©—æ•¸æ“šé—œä¿‚åœ–',
                xAxis: { label: 'æ“ä½œè®Šå› ', min: 0, max: 100, unit: 10 },
                yAxis: { label: 'æ‡‰è®Šè®Šå› ', min: 0, max: 50, unit: 5 },
                groups: JSON.parse(JSON.stringify(defaultGroupSettings)),
                dataPoints: [],
                activeGroupIndex: 0,
                showDataLabels: false
            };
            
            const padding = { top: 60, right: 150, bottom: 60, left: 70 };

            // --- äº’å‹•ç‹€æ…‹ ---
            let interactionState = 'idle'; // 'idle', 'draggingPoint', 'draggingEquation', 'selecting'
            let draggedPointIndex = -1;
            let draggedEquationIndex = -1;
            let selectionBox = { startX: 0, startY: 0, endX: 0, endY: 0, visible: false };
            let dragStartPos = { x: 0, y: 0 };
            let dragStartOffset = { dx: 0, dy: 0 };
            let interactionMoved = false;

            // --- AI åŠŸèƒ½å‡½æ•¸ ---
            async function getAIFeedback() {
                // 1. AI å‰ç½®æª¢æŸ¥
                const defaultTitle = "åœ–è¡¨æ¨™é¡Œ";
                const defaultXLabel = "æ“ä½œè®Šå› (å–®ä½)";
                const defaultYLabel = "æ‡‰è®Šè®Šå› (å–®ä½)";

                if (chartTitleInput.value.trim() === defaultTitle) {
                    aiFeedbackText.textContent = "è€å¸«ç™¼ç¾åœ–è¡¨çš„æ¨™é¡Œé‚„æ²’ä¿®æ”¹å–”ï¼ä¸€å€‹å¥½çš„æ¨™é¡Œå¯ä»¥è®“è®€è€…é¦¬ä¸Šäº†è§£é€™å€‹å¯¦é©—çš„ä¸»é¡Œã€‚è«‹å…ˆè©¦è‘—ç‚ºåœ–è¡¨å‘½åå§ï¼";
                    aiFeedbackContainer.style.display = 'block';
                    return;
                }
                if (xAxisLabelInput.value.trim() === defaultXLabel) {
                    aiFeedbackText.textContent = "è«‹å…ˆè¨­å®šå¥½æ©«è»¸çš„åç¨±èˆ‡å–®ä½ï¼Œé€™å°åˆ†ææ•¸æ“šå¾ˆé‡è¦å–”ï¼å°‘äº†å–®ä½ï¼Œæ•¸å­—å°±æ²’æœ‰æ„ç¾©äº†ã€‚";
                    aiFeedbackContainer.style.display = 'block';
                    return;
                }
                if (yAxisLabelInput.value.trim() === defaultYLabel) {
                    aiFeedbackText.textContent = "åˆ¥å¿˜äº†è¨­å®šç¸±è»¸çš„åç¨±èˆ‡å–®ä½å–”ï¼é€™æ¨£å¤§å®¶æ‰èƒ½çœ‹æ‡‚æ•¸æ“šä»£è¡¨ä»€éº¼ã€‚";
                    aiFeedbackContainer.style.display = 'block';
                    return;
                }

                // 2. å­¸ç”Ÿæ–‡å­—æª¢æŸ¥
                const studentText = studentAnalysisInput.value;
                if (!studentText.trim()) {
                    alert('è«‹å…ˆåœ¨ä¸Šæ–¹è¼¸å…¥æ¡†æ’°å¯«ä½ çš„åˆ†æå–”ï¼');
                    return;
                }

                submitForFeedbackBtn.disabled = true;
                submitForFeedbackBtn.textContent = 'AI è€å¸«æ€è€ƒä¸­...';
                aiFeedbackContainer.style.display = 'none';

                try {
                    // 3. æº–å‚™çµ¦ AI çš„è³‡æ–™
                    let chartDataSummary = `åœ–è¡¨æ¨™é¡Œ: ${chartState.title}\nXè»¸ (æ“ç¸±è®Šå› ): ${chartState.xAxis.label} (ç¯„åœ ${chartState.xAxis.min} åˆ° ${chartState.xAxis.max})\nYè»¸ (æ‡‰è®Šè®Šå› ): ${chartState.yAxis.label} (ç¯„åœ ${chartState.yAxis.min} åˆ° ${chartState.yAxis.max})\n`;

                    const enabledGroups = chartState.groups.filter(g => g.enabled);
                    if (enabledGroups.length === 0 || chartState.dataPoints.length === 0) {
                        alert('è«‹è‡³å°‘å•Ÿç”¨ä¸€å€‹æ•¸æ“šçµ„ä¸¦æ–°å¢ä¸€äº›æ•¸æ“šé»ï¼');
                        throw new Error("No data to analyze");
                    }

                    chartDataSummary += "\næ•¸æ“šé»åˆ†æ:\n";
                    enabledGroups.forEach(group => {
                        const groupIndex = chartState.groups.indexOf(group);
                        const points = chartState.dataPoints.filter(p => p.groupIndex === groupIndex);
                        if (points.length > 0) {
                            chartDataSummary += `\n- çµ„åˆ¥: "${group.name}"\n`;
                            chartDataSummary += "  æ•¸æ“šé» (X, Y): " + points.map(p => `(${p.x.toFixed(2)}, ${p.y.toFixed(2)})`).join(', ') + '\n';
                            if (group.trendline.visible && group.trendline.showEquation) {
                                const { m, b, r2, forceOrigin } = group.trendline;
                                let equationText = forceOrigin ? `y = ${m.toFixed(2)}x` : `y = ${m.toFixed(2)}x ${b >= 0 ? '+' : '-'} ${Math.abs(b).toFixed(2)}`;
                                chartDataSummary += `  è¶¨å‹¢ç·š: ${equationText}, RÂ² = ${r2.toFixed(3)}\n`;
                            }
                        }
                    });

                    const systemPrompt = `ä½ æ˜¯ä¸€ä½ä¾†è‡ªå°ç£ã€éå¸¸æœ‰è€å¿ƒä¸”å–„æ–¼å¼•å°çš„åœ‹ä¸­ç†åŒ–è€å¸«ã€‚ä½ çš„ç›®æ¨™ä¸æ˜¯çµ¦å­¸ç”Ÿæ‰“åˆ†æ•¸æˆ–ç›´æ¥æŒ‡å‡ºéŒ¯èª¤ï¼Œè€Œæ˜¯é€éæå•ä¾†å•Ÿç™¼ä»–å€‘å°æ•¸æ“šé€²è¡Œæ›´æ·±å…¥çš„æ€è€ƒã€‚è«‹ä½¿ç”¨æº«å’Œé¼“å‹µçš„èªæ°£ï¼Œä¸¦ä»¥æ­£é«”ä¸­æ–‡ç”Ÿæˆ 2 åˆ° 3 å€‹å¼•å°æ€§çš„å•é¡Œä½œç‚ºå›é¥‹ã€‚çµ•å°ä¸è¦èªªã€Œä½ å¯«éŒ¯äº†ã€æˆ–ã€Œä½ æ‡‰è©²è¦...ã€ï¼Œå›é¥‹çš„ä¸»è¦å½¢å¼å¿…é ˆæ˜¯å•å¥ã€‚`;
                    const userQuery = `é€™æ˜¯åœ–è¡¨çš„å®¢è§€æ•¸æ“šï¼š\n---\n${chartDataSummary.trim()}\n---\n\né€™æ˜¯å­¸ç”Ÿçš„åˆ†ææ–‡å­—ï¼š\n---\n${studentText}\n---\n\nè«‹æ ¹æ“šä»¥ä¸Šåœ–è¡¨æ•¸æ“šå’Œå­¸ç”Ÿåˆ†æï¼Œæä¾›å¼•å°æ€§çš„å•é¡Œå›é¥‹ã€‚`;
                    
                    const apiKey = ""; 
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
                    const payload = { contents: [{ parts: [{ text: userQuery }] }], systemInstruction: { parts: [{ text: systemPrompt }] } };
                    const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });

                    if (!response.ok) throw new Error(`API è«‹æ±‚å¤±æ•—: ${response.status}`);
                    const result = await response.json();
                    const feedback = result.candidates?.[0]?.content?.parts?.[0]?.text;
                    if (feedback) {
                        aiFeedbackText.textContent = feedback;
                        aiFeedbackContainer.style.display = 'block';
                    } else { throw new Error('å¾ AI æ”¶åˆ°çš„å›è¦†æ ¼å¼ä¸æ­£ç¢ºã€‚'); }
                } catch (error) {
                    console.error("AI feedback error:", error);
                    aiFeedbackText.textContent = 'æŠ±æ­‰ï¼ŒAI è€å¸«ç¾åœ¨æœ‰é»å¿™ï¼Œè«‹ç¨å¾Œå†è©¦ä¸€æ¬¡ã€‚\n' + error.message;
                    aiFeedbackContainer.style.display = 'block';
                } finally {
                    submitForFeedbackBtn.disabled = false;
                    submitForFeedbackBtn.textContent = 'æäº¤çµ¦ AI è€å¸«åˆ†æ';
                }
            }

            // --- åœ–è¡¨ç¹ªè£½èˆ‡äº’å‹•å‡½æ•¸ ---
            function initializeGroupSettings() {
                groupsContainer.innerHTML = '';
                for (let i = 0; i < MAX_GROUPS; i++) {
                    const group = chartState.groups[i];
                    const trendline = group.trendline;
                    const groupDiv = document.createElement('div');
                    groupDiv.className = 'p-3 border rounded-lg flex flex-col space-y-3';
                    groupDiv.innerHTML = `
                        <div class="flex items-center space-x-2">
                            <input type="radio" name="active-group" class="form-radio h-5 w-5 text-blue-600 group-active-radio focus:ring-blue-500" data-index="${i}" ${i === chartState.activeGroupIndex ? 'checked' : ''}>
                            <input type="checkbox" class="form-checkbox h-5 w-5 rounded text-blue-600 focus:ring-blue-500" data-index="${i}" data-type="group-enabled" ${group.enabled ? 'checked' : ''}>
                            <input type="text" value="${group.name}" class="text-sm flex-grow rounded-md border-gray-300 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50" data-index="${i}">
                            <input type="color" value="${group.color}" class="w-7 h-7 rounded-full border-none cursor-pointer color-input" data-index="${i}">
                            <select class="text-sm rounded-md border-gray-300 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50" data-index="${i}">
                                <option value="circle" ${group.shape === 'circle' ? 'selected' : ''}>åœ“å½¢</option>
                                <option value="square" ${group.shape === 'square' ? 'selected' : ''}>æ–¹å½¢</option>
                                <option value="triangle" ${group.shape === 'triangle' ? 'selected' : ''}>ä¸‰è§’</option>
                                <option value="cross" ${group.shape === 'cross' ? 'selected' : ''}>å‰å‰</option>
                            </select>
                        </div>
                        <div class="flex items-center space-x-3 text-sm">
                            <button class="flex-1 py-1 px-2 rounded-md bg-gray-200 hover:bg-gray-300 transition-colors trendline-btn" data-index="${i}">
                                ${trendline.visible ? 'æ¸…é™¤è¶¨å‹¢ç·š' : 'ç¹ªè£½è¶¨å‹¢ç·š'}
                            </button>
                            <label class="flex items-center space-x-1">
                                <input type="checkbox" class="form-checkbox h-4 w-4 rounded text-blue-600 focus:ring-blue-500" data-index="${i}" data-type="force-origin" ${trendline.forceOrigin ? 'checked' : ''}>
                                <span>é€šéåŸé»</span>
                            </label>
                            <label class="flex items-center space-x-1">
                                <input type="checkbox" class="form-checkbox h-4 w-4 rounded text-blue-600 focus:ring-blue-500" data-index="${i}" data-type="show-equation" ${trendline.showEquation ? 'checked' : ''}>
                                <span>é¡¯ç¤ºæ–¹ç¨‹å¼</span>
                            </label>
                        </div>
                    `;
                    groupsContainer.appendChild(groupDiv);
                }
                groupsContainer.querySelectorAll('input, select').forEach(el => el.addEventListener('change', updateGroupSettingsFromUI));
                groupsContainer.querySelectorAll('.trendline-btn').forEach(btn => btn.addEventListener('click', handleTrendlineButtonClick));
            }

            function handleTrendlineButtonClick(event) {
                const index = parseInt(event.target.dataset.index);
                const group = chartState.groups[index];
                group.trendline.visible = !group.trendline.visible;
                if (group.trendline.visible) recalculateTrendline(index);
                event.target.textContent = group.trendline.visible ? 'æ¸…é™¤è¶¨å‹¢ç·š' : 'ç¹ªè£½è¶¨å‹¢ç·š';
                redrawCanvas();
            }

            function recalculateTrendline(index) {
                const group = chartState.groups[index];
                group.trendline.equationPos = { x: null, y: null };
                const points = chartState.dataPoints.filter(p => p.groupIndex === index);
                if (points.length < 2) {
                    group.trendline.visible = false;
                    const btn = groupsContainer.querySelector(`.trendline-btn[data-index="${index}"]`);
                    if (btn) btn.textContent = 'ç¹ªè£½è¶¨å‹¢ç·š';
                    return;
                }
                let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
                const n = points.length;
                points.forEach(p => { sumX += p.x; sumY += p.y; sumXY += p.x * p.y; sumX2 += p.x * p.x; });
                let m, b;
                if (group.trendline.forceOrigin) { m = sumXY / sumX2; b = 0; } 
                else { m = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX); b = (sumY - m * sumX) / n; }
                group.trendline.m = m; group.trendline.b = b;
                const yMean = sumY / n; let ssTot = 0, ssRes = 0;
                points.forEach(p => { const yPred = m * p.x + b; ssTot += (p.y - yMean)**2; ssRes += (p.y - yPred)**2; });
                group.trendline.r2 = ssTot === 0 ? 1 : 1 - (ssRes / ssTot);
            }

            function updateGroupSettingsFromUI(event) {
                const index = parseInt(event.target.dataset.index), type = event.target.type, elType = event.target.dataset.type;
                if (type === 'radio') chartState.activeGroupIndex = index;
                else if (elType === 'group-enabled') chartState.groups[index].enabled = event.target.checked;
                else if (type === 'text') chartState.groups[index].name = event.target.value;
                else if (type === 'color') chartState.groups[index].color = event.target.value;
                else if (event.target.tagName.toLowerCase() === 'select') chartState.groups[index].shape = event.target.value;
                else if (elType === 'force-origin') { chartState.groups[index].trendline.forceOrigin = event.target.checked; if (chartState.groups[index].trendline.visible) recalculateTrendline(index); } 
                else if (elType === 'show-equation') chartState.groups[index].trendline.showEquation = event.target.checked;
                redrawCanvas();
            }

            function dataToCanvas(x, y) {
                const { clientWidth: canvasWidth, clientHeight: canvasHeight } = canvas.parentElement;
                const plotWidth = canvasWidth - padding.left - padding.right, plotHeight = canvasHeight - padding.top - padding.bottom;
                const canvasX = padding.left + (x - chartState.xAxis.min) / (chartState.xAxis.max - chartState.xAxis.min) * plotWidth;
                const canvasY = padding.top + plotHeight - (y - chartState.yAxis.min) / (chartState.yAxis.max - chartState.yAxis.min) * plotHeight;
                return { x: canvasX, y: canvasY };
            }

            function canvasToData(canvasX, canvasY) {
                const { clientWidth: canvasWidth, clientHeight: canvasHeight } = canvas.parentElement;
                const plotWidth = canvasWidth - padding.left - padding.right, plotHeight = canvasHeight - padding.top - padding.bottom;
                const x = chartState.xAxis.min + (canvasX - padding.left) / plotWidth * (chartState.xAxis.max - chartState.xAxis.min);
                const y = chartState.yAxis.min + (padding.top + plotHeight - canvasY) / plotHeight * (chartState.yAxis.max - chartState.yAxis.min);
                return { x, y };
            }
            
            function drawPoint(p) {
                const group = chartState.groups[p.groupIndex], pos = dataToCanvas(p.x, p.y);
                if (p.selected) { ctx.fillStyle = 'rgba(0, 120, 255, 0.3)'; ctx.beginPath(); ctx.arc(pos.x, pos.y, 10, 0, 2 * Math.PI); ctx.fill(); }
                ctx.fillStyle = group.color; ctx.strokeStyle = group.color; ctx.lineWidth = 2; ctx.beginPath();
                switch (group.shape) {
                    case 'circle': ctx.arc(pos.x, pos.y, 5, 0, 2 * Math.PI); ctx.fill(); break;
                    case 'square': ctx.fillRect(pos.x - 4, pos.y - 4, 8, 8); break;
                    case 'triangle': ctx.moveTo(pos.x, pos.y - 5); ctx.lineTo(pos.x + 5, pos.y + 5); ctx.lineTo(pos.x - 5, pos.y + 5); ctx.closePath(); ctx.fill(); break;
                    case 'cross': ctx.moveTo(pos.x - 4, pos.y - 4); ctx.lineTo(pos.x + 4, pos.y + 4); ctx.moveTo(pos.x + 4, pos.y - 4); ctx.lineTo(pos.x - 4, pos.y + 4); ctx.stroke(); break;
                }
            }
            
            function drawDataLabels() {
                if (!chartState.showDataLabels) return;
                ctx.font = '11px "Noto Sans TC"'; ctx.fillStyle = '#4b5563'; ctx.textAlign = 'left'; ctx.textBaseline = 'bottom';
                chartState.dataPoints.forEach(p => { if (chartState.groups[p.groupIndex].enabled) { const pos = dataToCanvas(p.x, p.y); ctx.fillText(`(${p.x.toFixed(1)}, ${p.y.toFixed(1)})`, pos.x + 8, pos.y - 8); } });
            }

            function drawAllPoints() { chartState.dataPoints.forEach(p => { if (chartState.groups[p.groupIndex].enabled) drawPoint(p); }); }

            function drawTrendlines() {
                chartState.groups.forEach(group => {
                    if (group.enabled && group.trendline.visible) {
                        const { m, b, r2, showEquation, equationPos } = group.trendline; const { xAxis, yAxis } = chartState;
                        let p1 = { x: xAxis.min, y: m * xAxis.min + b }, p2 = { x: xAxis.max, y: m * xAxis.max + b };
                        const clip = p => { if (p.y < yAxis.min) p = { x: m !== 0 ? (yAxis.min - b) / m : p.x, y: yAxis.min }; if (p.y > yAxis.max) p = { x: m !== 0 ? (yAxis.max - b) / m : p.x, y: yAxis.max }; if (p.x < xAxis.min) p = { x: xAxis.min, y: m * xAxis.min + b }; if (p.x > xAxis.max) p = { x: xAxis.max, y: m * xAxis.max + b }; return p; };
                        p1 = clip(p1); p2 = clip(p2);
                        const start = dataToCanvas(p1.x, p1.y), end = dataToCanvas(p2.x, p2.y);
                        ctx.beginPath(); ctx.moveTo(start.x, start.y); ctx.lineTo(end.x, end.y); ctx.strokeStyle = group.color; ctx.lineWidth = 2; ctx.stroke();
                        if (showEquation) {
                            ctx.font = '12px "Noto Sans TC"'; ctx.fillStyle = group.color; ctx.textAlign = 'right'; ctx.textBaseline = 'bottom';
                            let eq = group.trendline.forceOrigin ? `y = ${m.toFixed(2)}x` : `y = ${m.toFixed(2)}x ${b >= 0 ? '+' : '-'} ${Math.abs(b).toFixed(2)}`;
                            const r2Text = `RÂ² = ${r2.toFixed(3)}`; const textX = equationPos.x ?? end.x - 10, textY = equationPos.y ?? end.y - 10;
                            ctx.fillText(eq, textX, textY - 14); ctx.fillText(r2Text, textX, textY);
                            const maxWidth = Math.max(ctx.measureText(eq).width, ctx.measureText(r2Text).width);
                            group.trendline.equationBBox = { x: textX - maxWidth, y: textY - 28, width: maxWidth, height: 28 };
                        } else { group.trendline.equationBBox = null; }
                    }
                });
            }

            function drawGridAndAxes() {
                const dpr = window.devicePixelRatio || 1, cw = canvas.width / dpr, ch = canvas.height / dpr;
                ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.fillStyle = 'white'; ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.strokeStyle = '#e0e0e0'; ctx.fillStyle = '#333'; ctx.lineWidth = 1; ctx.font = '12px "Noto Sans TC"';
                const { xAxis, yAxis } = chartState; const xs = (xAxis.max - xAxis.min) / xAxis.unit, ys = (yAxis.max - yAxis.min) / yAxis.unit;
                for (let i = 0; i <= xs; i++) { const v = xAxis.min + i * xAxis.unit, { x } = dataToCanvas(v, yAxis.min); if (x < padding.left - 1 || x > cw - padding.right + 1) continue; ctx.beginPath(); ctx.moveTo(x, ch - padding.bottom); ctx.lineTo(x, ch - padding.bottom + 5); ctx.stroke(); ctx.textAlign = 'center'; ctx.fillText(Number.isInteger(v) ? v : v.toFixed(1), x, ch - padding.bottom + 20); if (i > 0) { ctx.beginPath(); ctx.moveTo(x, ch - padding.bottom); ctx.lineTo(x, padding.top); ctx.stroke(); } }
                for (let i = 0; i <= ys; i++) { const v = yAxis.min + i * yAxis.unit, { y } = dataToCanvas(xAxis.min, v); if (y < padding.top - 1 || y > ch - padding.bottom + 1) continue; ctx.beginPath(); ctx.moveTo(padding.left, y); ctx.lineTo(padding.left - 5, y); ctx.stroke(); ctx.textAlign = 'right'; ctx.textBaseline = 'middle'; ctx.fillText(Number.isInteger(v) ? v : v.toFixed(1), padding.left - 10, y); if (i > 0) { ctx.beginPath(); ctx.moveTo(padding.left, y); ctx.lineTo(cw - padding.right, y); ctx.stroke(); } }
                ctx.strokeStyle = '#333'; ctx.beginPath(); ctx.moveTo(padding.left, padding.top); ctx.lineTo(padding.left, ch - padding.bottom); ctx.lineTo(cw - padding.right, ch - padding.bottom); ctx.stroke();
                ctx.font = 'bold 20px "Noto Sans TC"'; ctx.textAlign = 'center'; ctx.fillText(chartState.title, cw / 2, padding.top / 2); ctx.font = '16px "Noto Sans TC"'; ctx.fillText(xAxis.label, cw / 2, ch - 10);
                ctx.save(); ctx.translate(20, ch / 2); ctx.rotate(-Math.PI / 2); ctx.fillText(yAxis.label, 0, 0); ctx.restore();
            }

            function drawLegend() {
                const cw = canvas.width / (window.devicePixelRatio || 1); let y = padding.top;
                ctx.font = '12px "Noto Sans TC"';
                chartState.groups.forEach(g => { if (g.enabled) { const x = cw - padding.right + 15; ctx.fillStyle = g.color; ctx.strokeStyle = g.color; ctx.lineWidth = 2; ctx.beginPath(); switch (g.shape) { case 'circle': ctx.arc(x, y, 5, 0, 2 * Math.PI); ctx.fill(); break; case 'square': ctx.fillRect(x - 4, y - 4, 8, 8); break; case 'triangle': ctx.moveTo(x, y - 5); ctx.lineTo(x + 5, y + 5); ctx.lineTo(x - 5, y + 5); ctx.closePath(); ctx.fill(); break; case 'cross': ctx.moveTo(x - 4, y - 4); ctx.lineTo(x + 4, y + 4); ctx.moveTo(x + 4, y - 4); ctx.lineTo(x - 4, y + 4); ctx.stroke(); break; } ctx.textAlign = 'left'; ctx.textBaseline = 'middle'; ctx.fillStyle = '#333'; ctx.fillText(g.name, x + 15, y); y += 25; } });
            }

            function drawSelectionBox() { if (selectionBox.visible) { ctx.fillStyle = 'rgba(0, 120, 255, 0.2)'; ctx.strokeStyle = 'rgba(0, 120, 255, 0.8)'; ctx.lineWidth = 1; const x = Math.min(selectionBox.startX, selectionBox.endX), y = Math.min(selectionBox.startY, selectionBox.endY), w = Math.abs(selectionBox.startX - selectionBox.endX), h = Math.abs(selectionBox.startY - selectionBox.endY); ctx.fillRect(x, y, w, h); ctx.strokeRect(x, y, w, h); } }
            function redrawCanvas() { const rect = canvas.parentElement.getBoundingClientRect(), dpr = window.devicePixelRatio || 1; if (rect.width === 0 || rect.height === 0) return; canvas.width = rect.width * dpr; canvas.height = rect.height * dpr; ctx.scale(dpr, dpr); drawGridAndAxes(); drawAllPoints(); drawTrendlines(); drawDataLabels(); drawLegend(); drawSelectionBox(); }
            function getPointAtPos(x, y) { for (let i = chartState.dataPoints.length - 1; i >= 0; i--) { const p = chartState.dataPoints[i]; if (chartState.groups[p.groupIndex].enabled) { const pos = dataToCanvas(p.x, p.y); if (Math.hypot(x - pos.x, y - pos.y) <= 10) return i; } } return -1; }
            function getEquationAtPos(x, y) { for (let i = 0; i < chartState.groups.length; i++) { const g = chartState.groups[i]; if (g.enabled && g.trendline.visible && g.trendline.showEquation && g.trendline.equationBBox) { const b = g.trendline.equationBBox; if (x >= b.x && x <= b.x + b.width && y >= b.y && y <= b.y + b.height) return i; } } return -1; }
            function handleInteractionStart(x, y, e) { e.preventDefault(); interactionMoved = false; dragStartPos = { x, y }; draggedPointIndex = getPointAtPos(x, y); draggedEquationIndex = getEquationAtPos(x, y); if (draggedPointIndex !== -1) { interactionState = 'draggingPoint'; const p = chartState.dataPoints[draggedPointIndex]; if (!e.shiftKey && !p.selected) { chartState.dataPoints.forEach(pt => pt.selected = false); p.selected = true; } chartState.dataPoints.forEach(pt => { if (pt.selected) { pt.dragStartX = pt.x; pt.dragStartY = pt.y; } }); } else if (draggedEquationIndex !== -1) { interactionState = 'draggingEquation'; const g = chartState.groups[draggedEquationIndex].trendline; const b = g.equationBBox; const tx = g.equationPos.x ?? b.x + b.width, ty = g.equationPos.y ?? b.y + b.height; dragStartOffset = { dx: x - tx, dy: y - ty }; } else { interactionState = 'selecting'; if (!e.shiftKey) chartState.dataPoints.forEach(p => p.selected = false); selectionBox = { startX: x, startY: y, endX: x, endY: y, visible: true }; } redrawCanvas(); }
            function handleInteractionMove(x, y, e) { if (interactionState === 'idle') { canvas.style.cursor = getEquationAtPos(x, y) !== -1 ? 'move' : getPointAtPos(x, y) !== -1 ? 'pointer' : 'crosshair'; return; } e.preventDefault(); interactionMoved = true; if (interactionState === 'draggingPoint') { const sd = canvasToData(dragStartPos.x, dragStartPos.y), cd = canvasToData(x, y); const dx = cd.x - sd.x, dy = cd.y - sd.y; chartState.dataPoints.forEach(p => { if (p.selected) { p.x = p.dragStartX + dx; p.y = p.dragStartY + dy; } }); } else if (interactionState === 'draggingEquation') { chartState.groups[draggedEquationIndex].trendline.equationPos = { x: x - dragStartOffset.dx, y: y - dragStartOffset.dy }; } else if (interactionState === 'selecting') { selectionBox.endX = x; selectionBox.endY = y; } redrawCanvas(); }
            function handleInteractionEnd(e) { if (interactionState === 'idle') return; e.preventDefault(); if (interactionState === 'draggingPoint') { const groups = new Set(chartState.dataPoints.filter(p => p.selected).map(p => p.groupIndex)); groups.forEach(i => { if (chartState.groups[i].trendline.visible) recalculateTrendline(i); }); } else if (interactionState === 'selecting') { const x1 = Math.min(selectionBox.startX, selectionBox.endX), y1 = Math.min(selectionBox.startY, selectionBox.endY), x2 = Math.max(selectionBox.startX, selectionBox.endX), y2 = Math.max(selectionBox.startY, selectionBox.endY); chartState.dataPoints.forEach(p => { const pos = dataToCanvas(p.x, p.y); if (pos.x >= x1 && pos.x <= x2 && pos.y >= y1 && pos.y <= y2) p.selected = true; }); } if (!interactionMoved) { if (draggedPointIndex !== -1) { const p = chartState.dataPoints[draggedPointIndex]; if (e.shiftKey) p.selected = !p.selected; else { chartState.dataPoints.forEach(pt => pt.selected = false); p.selected = true; } } else if (draggedEquationIndex === -1) { if (!e.shiftKey) chartState.dataPoints.forEach(p => p.selected = false); const d = canvasToData(dragStartPos.x, dragStartPos.y); if (d.x >= chartState.xAxis.min && d.x <= chartState.xAxis.max && d.y >= chartState.yAxis.min && d.y <= chartState.yAxis.max) { chartState.dataPoints.push({ x: d.x, y: d.y, groupIndex: chartState.activeGroupIndex, selected: false }); if (chartState.groups[chartState.activeGroupIndex].trendline.visible) recalculateTrendline(chartState.activeGroupIndex); } } } chartState.dataPoints.forEach(p => { delete p.dragStartX; delete p.dragStartY; }); interactionState = 'idle'; draggedPointIndex = -1; draggedEquationIndex = -1; selectionBox.visible = false; redrawCanvas(); }

            // --- äº‹ä»¶ç›£è½ ---
            applyBtn.addEventListener('click', () => { const xMin = parseFloat(xAxisMinInput.value), xMax = parseFloat(xAxisMaxInput.value), yMin = parseFloat(yAxisMinInput.value), yMax = parseFloat(yAxisMaxInput.value), xUnit = parseFloat(xAxisUnitInput.value), yUnit = parseFloat(yAxisUnitInput.value); if (xMin >= xMax || yMin >= yMax || xUnit <= 0 || yUnit <= 0) { alert('åº§æ¨™è»¸ç¯„åœæˆ–å–®ä½è¨­å®šæœ‰èª¤ï¼'); return; } chartState.title = chartTitleInput.value; chartState.xAxis = { label: xAxisLabelInput.value, min: xMin, max: xMax, unit: xUnit }; chartState.yAxis = { label: yAxisLabelInput.value, min: yMin, max: yMax, unit: yUnit }; chartState.dataPoints = []; chartState.groups.forEach(g => { g.trendline.visible = false; }); initializeGroupSettings(); redrawCanvas(); });
            showLabelsToggle.addEventListener('change', (e) => { chartState.showDataLabels = e.target.checked; redrawCanvas(); });
            submitForFeedbackBtn.addEventListener('click', getAIFeedback);
            showHintBtn.addEventListener('click', () => { hintModal.style.display = 'flex'; setTimeout(() => hintModalContent.classList.add('scale-100', 'opacity-100'), 10); });
            closeHintModalBtn.addEventListener('click', () => { hintModalContent.classList.remove('scale-100', 'opacity-100'); setTimeout(() => hintModal.style.display = 'none', 300); });
            hintModal.addEventListener('click', (e) => { if (e.target === hintModal) closeHintModalBtn.click(); });
            downloadBtn.addEventListener('click', () => { chartState.dataPoints.forEach(p => p.selected = false); redrawCanvas(); const link = document.createElement('a'); link.download = `${chartState.title.replace(/\s+/g, '_') || 'chart'}.png`; link.href = canvas.toDataURL('image/png'); link.click(); });
            downloadDataBtn.addEventListener('click', () => { let csv = "data:text/csv;charset=utf-8,çµ„åˆ¥,Xè»¸æ•¸å€¼,Yè»¸æ•¸å€¼\n"; chartState.dataPoints.forEach(p => { csv += `${chartState.groups[p.groupIndex].name},${p.x.toFixed(3)},${p.y.toFixed(3)}\n`; }); const link = document.createElement('a'); link.href = encodeURI(csv); link.download = `${chartState.title.replace(/\s+/g, '_') || 'chart_data'}.csv`; document.body.appendChild(link); link.click(); document.body.removeChild(link); });
            canvas.addEventListener('mousedown', (e) => handleInteractionStart(e.offsetX, e.offsetY, e)); canvas.addEventListener('mousemove', (e) => handleInteractionMove(e.offsetX, e.offsetY, e)); window.addEventListener('mouseup', (e) => handleInteractionEnd(e));
            canvas.addEventListener('touchstart', (e) => { const r = canvas.getBoundingClientRect(); handleInteractionStart(e.touches[0].clientX - r.left, e.touches[0].clientY - r.top, e); });
            canvas.addEventListener('touchmove', (e) => { const r = canvas.getBoundingClientRect(); handleInteractionMove(e.touches[0].clientX - r.left, e.touches[0].clientY - r.top, e); });
            canvas.addEventListener('touchend', (e) => handleInteractionEnd(e)); canvas.addEventListener('touchcancel', (e) => handleInteractionEnd(e));
            document.addEventListener('keydown', (e) => { if (e.key === 'Delete' || e.key === 'Backspace') { const groups = new Set(chartState.dataPoints.filter(p => p.selected).map(p => p.groupIndex)); chartState.dataPoints = chartState.dataPoints.filter(p => !p.selected); groups.forEach(i => { if (chartState.groups[i].trendline.visible) recalculateTrendline(i); }); redrawCanvas(); } });
            window.addEventListener('resize', redrawCanvas);

            // --- åˆå§‹å•Ÿå‹• ---
            initializeGroupSettings(); setTimeout(() => { applyBtn.click(); }, 100);
        });
    </script>

</body>
</html>

