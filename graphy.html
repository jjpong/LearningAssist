<!DOCTYPE html>
<html lang="zh-Hant" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>實驗數據統計圖繪製工具</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 使用 Google Fonts 的 Noto Sans TC 字體 */
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&display=swap');
        html, body {
            font-family: 'Noto Sans TC', sans-serif;
            background-color: #f0f2f5;
            overflow: hidden; /* 禁用頁面主滾動條 */
        }
        /* 自訂樣式 */
        .group-active-radio:checked { background-color: #2563eb; border-color: #2563eb; }
        .color-input::-webkit-color-swatch-wrapper { padding: 0; }
        .color-input::-webkit-color-swatch { border: none; border-radius: 50%; }
        canvas { cursor: crosshair; touch-action: none; } /* touch-action: none 防止觸控時的滾動等預設行為 */
        .canvas-bg-white { background-color: white; }
        /* 美化滾動條 */
        .custom-scrollbar::-webkit-scrollbar { width: 8px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 10px; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #c7c7c7; border-radius: 10px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #a8a8a8; }
    </style>
</head>
<body class="h-full text-gray-800">

    <!-- 全螢幕佈局容器 -->
    <div class="h-screen flex flex-col p-4 lg:p-6 gap-4">
        <!-- 應用程式標題 (固定高度) -->
        <header class="text-center flex-shrink-0">
            <h1 class="text-3xl lg:text-4xl font-bold text-gray-700">實驗數據統計圖繪製工具</h1>
        </header>

        <!-- 主內容區 (填滿剩餘空間) -->
        <main class="flex-grow grid grid-cols-1 lg:grid-cols-8 gap-6 overflow-hidden">

            <!-- 左側：圖表與功能區 (固定不滾動) -->
            <div class="lg:col-span-5 flex flex-col h-full">
                <div class="bg-white p-4 rounded-xl shadow-lg h-full flex flex-col">
                    <!-- 畫布容器 (自動伸展) -->
                    <div class="relative w-full flex-grow">
                        <canvas id="chart-canvas" class="absolute top-0 left-0 w-full h-full rounded-lg border border-gray-300 canvas-bg-white"></canvas>
                    </div>
                </div>
            </div>
            
            <!-- 右側：設定與數據面板 (內部可滾動) -->
            <div class="lg:col-span-3 space-y-6 overflow-y-auto custom-scrollbar pr-3">
                <!-- 設定面板 -->
                <div class="bg-white p-5 rounded-xl shadow-lg">
                    <h2 class="text-xl font-bold mb-4 border-b pb-2">一、圖表設定</h2>
                    
                    <div class="space-y-4 mb-6">
                        <div>
                              <h3 class="text-lg font-semibold text-gray-700">1.填入適當的圖表標題</h3>
                            <input type="text" id="chart-title" value="圖表標題" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50">
                        </div>
                    </div>

                    <div class="space-y-4 mb-6">
                        <h3 class="text-lg font-semibold text-gray-700">2.設定操縱變因(單位)，刻度範圍和每格單位</h3>
                        <div>
                            <label for="x-axis-label" class="block text-sm font-medium text-gray-600">設定橫軸</label>
                            <input type="text" id="x-axis-label" value="操作變因(單位)" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50">
                        </div>
                        <div class="grid grid-cols-2 gap-4">
                            <div>
                                <label for="x-axis-min" class="block text-sm font-medium text-gray-600">最小值</label>
                                <input type="number" id="x-axis-min" value="0" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50">
                            </div>
                            <div>
                                <label for="x-axis-max" class="block text-sm font-medium text-gray-600">最大值</label>
                                <input type="number" id="x-axis-max" value="100" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50">
                            </div>
                        </div>
                        <div>
                            <label for="x-axis-unit" class="block text-sm font-medium text-gray-600">每格單位</label>
                            <input type="number" id="x-axis-unit" value="10" min="0.5" step="0.5" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50">
                        </div>
                    </div>

                    <div class="space-y-4 mb-6">
                        <h3 class="text-lg font-semibold text-gray-700">3.設定應變變因(單位)，刻度範圍和每格單位</h3>
                        <div>
                            <label for="y-axis-label" class="block text-sm font-medium text-gray-600">設定縱軸</label>
                            <input type="text" id="y-axis-label" value="應變變因(單位)" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50">
                        </div>
                         <div class="grid grid-cols-2 gap-4">
                            <div>
                                <label for="y-axis-min" class="block text-sm font-medium text-gray-600">最小值</label>
                                <input type="number" id="y-axis-min" value="0" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50">
                            </div>
                            <div>
                                <label for="y-axis-max" class="block text-sm font-medium text-gray-600">最大值</label>
                                <input type="number" id="y-axis-max" value="50" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50">
                            </div>
                        </div>
                        <div>
                            <label for="y-axis-unit" class="block text-sm font-medium text-gray-600">每格單位</label>
                            <input type="number" id="y-axis-unit" value="5" min="0.5" step="0.5" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50">
                        </div>
                    </div>
                    <button id="apply-settings" class="w-full bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 transition-colors mt-4">套用設定(會清空數據)</button>
                </div>

                <div class="bg-white p-5 rounded-xl shadow-lg">
                    <h2 class="text-xl font-bold mb-4 border-b pb-2">二、數據操作</h2>
                    <div id="groups-container" class="space-y-3">
                        <!-- JavaScript 會在這裡動態生成 4 組設定 -->
                    </div>
                    <!-- 修正後的數據標籤開關 -->
                    <div class="mt-4 bg-gray-50 p-3 rounded-lg">
                        <label for="show-labels-toggle" class="flex items-center justify-between cursor-pointer">
                            <span class="font-semibold text-gray-700">顯示數據標籤</span>
                            <div class="relative inline-flex items-center">
                                <input type="checkbox" id="show-labels-toggle" class="sr-only peer">
                                <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                            </div>
                        </label>
                    </div>
                    <div class="mt-6 space-y-3">
                        <button id="download-chart" class="w-full bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700 transition-colors">下載圖表 (PNG)</button>
                        <button id="download-data" class="w-full bg-orange-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-orange-600 transition-colors">下載數據 (CSV)</button>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM 元素 ---
            const canvas = document.getElementById('chart-canvas');
            const ctx = canvas.getContext('2d');
            const chartTitleInput = document.getElementById('chart-title');
            const xAxisLabelInput = document.getElementById('x-axis-label');
            const xAxisMinInput = document.getElementById('x-axis-min');
            const xAxisMaxInput = document.getElementById('x-axis-max');
            const xAxisUnitInput = document.getElementById('x-axis-unit');
            const yAxisLabelInput = document.getElementById('y-axis-label');
            const yAxisMinInput = document.getElementById('y-axis-min');
            const yAxisMaxInput = document.getElementById('y-axis-max');
            const yAxisUnitInput = document.getElementById('y-axis-unit');
            const groupsContainer = document.getElementById('groups-container');
            const applyBtn = document.getElementById('apply-settings');
            const downloadBtn = document.getElementById('download-chart');
            const downloadDataBtn = document.getElementById('download-data');
            const showLabelsToggle = document.getElementById('show-labels-toggle');

            // --- 初始設定與狀態 ---
            const MAX_GROUPS = 4;
            const defaultGroupSettings = [
                { name: '實驗 A', color: '#3b82f6', shape: 'circle', enabled: true, trendline: { visible: false, m: 0, b: 0, r2: 0, forceOrigin: false, showEquation: false, equationPos: { x: null, y: null }, equationBBox: null } },
                { name: '實驗 B', color: '#ef4444', shape: 'square', enabled: false, trendline: { visible: false, m: 0, b: 0, r2: 0, forceOrigin: false, showEquation: false, equationPos: { x: null, y: null }, equationBBox: null } },
                { name: '實驗 C', color: '#22c55e', shape: 'triangle', enabled: false, trendline: { visible: false, m: 0, b: 0, r2: 0, forceOrigin: false, showEquation: false, equationPos: { x: null, y: null }, equationBBox: null } },
                { name: '實驗 D', color: '#f97316', shape: 'cross', enabled: false, trendline: { visible: false, m: 0, b: 0, r2: 0, forceOrigin: false, showEquation: false, equationPos: { x: null, y: null }, equationBBox: null } }
            ];

            let chartState = {
                title: '實驗數據關係圖',
                xAxis: { label: '操作變因', min: 0, max: 100, unit: 10 },
                yAxis: { label: '應變變因', min: 0, max: 50, unit: 5 },
                groups: JSON.parse(JSON.stringify(defaultGroupSettings)),
                dataPoints: [],
                activeGroupIndex: 0,
                showDataLabels: false
            };
            
            const padding = { top: 60, right: 150, bottom: 60, left: 70 };

            // --- 互動狀態 ---
            let interactionState = 'idle'; // 'idle', 'draggingPoint', 'draggingEquation', 'selecting'
            let draggedPointIndex = -1;
            let draggedEquationIndex = -1;
            let selectionBox = { startX: 0, startY: 0, endX: 0, endY: 0, visible: false };
            let dragStartPos = { x: 0, y: 0 };
            let dragStartOffset = { dx: 0, dy: 0 };
            let interactionMoved = false;

            // --- 函數 ---
            function initializeGroupSettings() {
                groupsContainer.innerHTML = '';
                for (let i = 0; i < MAX_GROUPS; i++) {
                    const group = chartState.groups[i];
                    const trendline = group.trendline;
                    const groupDiv = document.createElement('div');
                    groupDiv.className = 'p-3 border rounded-lg flex flex-col space-y-3';
                    groupDiv.innerHTML = `
                        <div class="flex items-center space-x-2">
                            <input type="radio" name="active-group" class="form-radio h-5 w-5 text-blue-600 group-active-radio focus:ring-blue-500" data-index="${i}" ${i === chartState.activeGroupIndex ? 'checked' : ''}>
                            <input type="checkbox" class="form-checkbox h-5 w-5 rounded text-blue-600 focus:ring-blue-500" data-index="${i}" data-type="group-enabled" ${group.enabled ? 'checked' : ''}>
                            <input type="text" value="${group.name}" class="text-sm flex-grow rounded-md border-gray-300 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50" data-index="${i}">
                            <input type="color" value="${group.color}" class="w-7 h-7 rounded-full border-none cursor-pointer color-input" data-index="${i}">
                            <select class="text-sm rounded-md border-gray-300 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50" data-index="${i}">
                                <option value="circle" ${group.shape === 'circle' ? 'selected' : ''}>圓形</option>
                                <option value="square" ${group.shape === 'square' ? 'selected' : ''}>方形</option>
                                <option value="triangle" ${group.shape === 'triangle' ? 'selected' : ''}>三角</option>
                                <option value="cross" ${group.shape === 'cross' ? 'selected' : ''}>叉叉</option>
                            </select>
                        </div>
                        <div class="flex items-center space-x-3 text-sm">
                            <button class="flex-1 py-1 px-2 rounded-md bg-gray-200 hover:bg-gray-300 transition-colors trendline-btn" data-index="${i}">
                                ${trendline.visible ? '清除趨勢線' : '繪製趨勢線'}
                            </button>
                            <label class="flex items-center space-x-1">
                                <input type="checkbox" class="form-checkbox h-4 w-4 rounded text-blue-600 focus:ring-blue-500" data-index="${i}" data-type="force-origin" ${trendline.forceOrigin ? 'checked' : ''}>
                                <span>通過原點</span>
                            </label>
                            <label class="flex items-center space-x-1">
                                <input type="checkbox" class="form-checkbox h-4 w-4 rounded text-blue-600 focus:ring-blue-500" data-index="${i}" data-type="show-equation" ${trendline.showEquation ? 'checked' : ''}>
                                <span>顯示方程式</span>
                            </label>
                        </div>
                    `;
                    groupsContainer.appendChild(groupDiv);
                }

                groupsContainer.querySelectorAll('input, select').forEach(el => {
                    el.addEventListener('change', updateGroupSettingsFromUI);
                });
                groupsContainer.querySelectorAll('.trendline-btn').forEach(btn => {
                    btn.addEventListener('click', handleTrendlineButtonClick);
                });
            }

            function handleTrendlineButtonClick(event) {
                const index = parseInt(event.target.dataset.index);
                const group = chartState.groups[index];
                group.trendline.visible = !group.trendline.visible;

                if (group.trendline.visible) {
                    recalculateTrendline(index);
                }
                
                const btn = groupsContainer.querySelector(`.trendline-btn[data-index="${index}"]`);
                btn.textContent = group.trendline.visible ? '清除趨勢線' : '繪製趨勢線';
                redrawCanvas();
            }

            function recalculateTrendline(index) {
                const group = chartState.groups[index];
                // Reset equation position when recalculating
                group.trendline.equationPos = { x: null, y: null };

                const points = chartState.dataPoints.filter(p => p.groupIndex === index);

                if (points.length < 2) {
                    group.trendline.visible = false;
                    const btn = groupsContainer.querySelector(`.trendline-btn[data-index="${index}"]`);
                    if (btn) btn.textContent = '繪製趨勢線';
                    return;
                }

                let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
                const n = points.length;
                points.forEach(p => {
                    sumX += p.x;
                    sumY += p.y;
                    sumXY += p.x * p.y;
                    sumX2 += p.x * p.x;
                });

                let m, b;
                if (group.trendline.forceOrigin) {
                    m = sumXY / sumX2;
                    b = 0;
                } else {
                    m = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
                    b = (sumY - m * sumX) / n;
                }
                
                group.trendline.m = m;
                group.trendline.b = b;

                // Calculate R^2
                const yMean = sumY / n;
                let ssTot = 0;
                let ssRes = 0;
                points.forEach(p => {
                    const yPred = m * p.x + b;
                    ssTot += (p.y - yMean)**2;
                    ssRes += (p.y - yPred)**2;
                });
                group.trendline.r2 = ssTot === 0 ? 1 : 1 - (ssRes / ssTot);
            }

            function updateGroupSettingsFromUI(event) {
                const index = parseInt(event.target.dataset.index);
                const type = event.target.type;
                const elType = event.target.dataset.type;

                if (type === 'radio') {
                    chartState.activeGroupIndex = index;
                } else if (elType === 'group-enabled') {
                    chartState.groups[index].enabled = event.target.checked;
                } else if (type === 'text') {
                    chartState.groups[index].name = event.target.value;
                } else if (type === 'color') {
                    chartState.groups[index].color = event.target.value;
                } else if (event.target.tagName.toLowerCase() === 'select') {
                    chartState.groups[index].shape = event.target.value;
                } else if (elType === 'force-origin') {
                    chartState.groups[index].trendline.forceOrigin = event.target.checked;
                    if (chartState.groups[index].trendline.visible) recalculateTrendline(index);
                } else if (elType === 'show-equation') {
                    chartState.groups[index].trendline.showEquation = event.target.checked;
                }
                
                redrawCanvas();
            }

            function dataToCanvas(x, y) {
                const canvasWidth = canvas.parentElement.clientWidth;
                const canvasHeight = canvas.parentElement.clientHeight;
                const plotWidth = canvasWidth - padding.left - padding.right;
                const plotHeight = canvasHeight - padding.top - padding.bottom;

                const canvasX = padding.left + (x - chartState.xAxis.min) / (chartState.xAxis.max - chartState.xAxis.min) * plotWidth;
                const canvasY = padding.top + plotHeight - (y - chartState.yAxis.min) / (chartState.yAxis.max - chartState.yAxis.min) * plotHeight;
                return { x: canvasX, y: canvasY };
            }

            function canvasToData(canvasX, canvasY) {
                const canvasWidth = canvas.parentElement.clientWidth;
                const canvasHeight = canvas.parentElement.clientHeight;
                const plotWidth = canvasWidth - padding.left - padding.right;
                const plotHeight = canvasHeight - padding.top - padding.bottom;

                const x = chartState.xAxis.min + (canvasX - padding.left) / plotWidth * (chartState.xAxis.max - chartState.xAxis.min);
                const y = chartState.yAxis.min + (padding.top + plotHeight - canvasY) / plotHeight * (chartState.yAxis.max - chartState.yAxis.min);
                return { x, y };
            }
            
            function drawPoint(p, index) {
                const group = chartState.groups[p.groupIndex];
                const pos = dataToCanvas(p.x, p.y);
                
                if (p.selected) {
                    ctx.fillStyle = 'rgba(0, 120, 255, 0.3)';
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, 10, 0, 2 * Math.PI);
                    ctx.fill();
                }

                ctx.fillStyle = group.color;
                ctx.strokeStyle = group.color;
                ctx.lineWidth = 2;
                ctx.beginPath();

                switch (group.shape) {
                    case 'circle':
                        ctx.arc(pos.x, pos.y, 5, 0, 2 * Math.PI);
                        ctx.fill();
                        break;
                    case 'square':
                        ctx.fillRect(pos.x - 4, pos.y - 4, 8, 8);
                        break;
                    case 'triangle':
                        ctx.moveTo(pos.x, pos.y - 5);
                        ctx.lineTo(pos.x + 5, pos.y + 5);
                        ctx.lineTo(pos.x - 5, pos.y + 5);
                        ctx.closePath();
                        ctx.fill();
                        break;
                    case 'cross':
                        ctx.moveTo(pos.x - 4, pos.y - 4);
                        ctx.lineTo(pos.x + 4, pos.y + 4);
                        ctx.moveTo(pos.x + 4, pos.y - 4);
                        ctx.lineTo(pos.x - 4, pos.y + 4);
                        ctx.stroke();
                        break;
                }
            }
            
            function drawDataLabels() {
                if (!chartState.showDataLabels) return;

                ctx.font = '11px "Noto Sans TC"';
                ctx.fillStyle = '#4b5563'; // gray-600
                ctx.textAlign = 'left';
                ctx.textBaseline = 'bottom';

                chartState.dataPoints.forEach(p => {
                    if (chartState.groups[p.groupIndex].enabled) {
                        const pos = dataToCanvas(p.x, p.y);
                        const label = `(${p.x.toFixed(1)}, ${p.y.toFixed(1)})`;
                        ctx.fillText(label, pos.x + 8, pos.y - 8);
                    }
                });
            }

            function drawAllPoints() {
                chartState.dataPoints.forEach((p, index) => {
                    if (chartState.groups[p.groupIndex].enabled) {
                        drawPoint(p, index);
                    }
                });
            }

            function drawTrendlines() {
                chartState.groups.forEach(group => {
                    if (group.enabled && group.trendline.visible) {
                        const { m, b, r2, showEquation, equationPos } = group.trendline;
                        const xAxis = chartState.xAxis;
                        const yAxis = chartState.yAxis;

                        let p1 = { x: xAxis.min, y: m * xAxis.min + b };
                        let p2 = { x: xAxis.max, y: m * xAxis.max + b };

                        const clipPoint = (p) => {
                            if (p.y < yAxis.min) {
                                if (m !== 0) p.x = (yAxis.min - b) / m;
                                p.y = yAxis.min;
                            } else if (p.y > yAxis.max) {
                                if (m !== 0) p.x = (yAxis.max - b) / m;
                                p.y = yAxis.max;
                            }
                            if (p.x < xAxis.min) {
                                p.y = m * xAxis.min + b;
                                p.x = xAxis.min;
                            } else if (p.x > xAxis.max) {
                                p.y = m * xAxis.max + b;
                                p.x = xAxis.max;
                            }
                            return p;
                        };
                        
                        p1 = clipPoint(p1);
                        p2 = clipPoint(p2);

                        const startPoint = dataToCanvas(p1.x, p1.y);
                        const endPoint = dataToCanvas(p2.x, p2.y);

                        ctx.beginPath();
                        ctx.moveTo(startPoint.x, startPoint.y);
                        ctx.lineTo(endPoint.x, endPoint.y);
                        ctx.strokeStyle = group.color;
                        ctx.lineWidth = 2;
                        ctx.stroke();

                        if (showEquation) {
                            ctx.font = '12px "Noto Sans TC"';
                            ctx.fillStyle = group.color;
                            ctx.textAlign = 'right';
                            ctx.textBaseline = 'bottom';

                            let equationText;
                            if (group.trendline.forceOrigin) {
                                equationText = `y = ${m.toFixed(2)}x`;
                            } else {
                                const operator = b >= 0 ? '+' : '-';
                                equationText = `y = ${m.toFixed(2)}x ${operator} ${Math.abs(b).toFixed(2)}`;
                            }
                            const r2Text = `R² = ${r2.toFixed(3)}`;
                            
                            // Determine text position
                            const textX = equationPos.x !== null ? equationPos.x : endPoint.x - 10;
                            const textY = equationPos.y !== null ? equationPos.y : endPoint.y - 10;
                            
                            ctx.fillText(equationText, textX, textY - 14);
                            ctx.fillText(r2Text, textX, textY);
                            
                            // Store bounding box for hit detection
                            const eqWidth = ctx.measureText(equationText).width;
                            const r2Width = ctx.measureText(r2Text).width;
                            const maxWidth = Math.max(eqWidth, r2Width);
                            const textHeight = 12 * 2.2; // Two lines of text with some padding
                            group.trendline.equationBBox = {
                                x: textX - maxWidth,
                                y: textY - textHeight,
                                width: maxWidth,
                                height: textHeight
                            };
                        } else {
                           group.trendline.equationBBox = null; 
                        }
                    }
                });
            }

            function drawGridAndAxes() {
                const canvasWidth = canvas.width / (window.devicePixelRatio || 1);
                const canvasHeight = canvas.height / (window.devicePixelRatio || 1);

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.strokeStyle = '#e0e0e0';
                ctx.fillStyle = '#333';
                ctx.lineWidth = 1;
                ctx.font = '12px "Noto Sans TC"';

                const xAxis = chartState.xAxis;
                const yAxis = chartState.yAxis;

                const xSteps = (xAxis.max - xAxis.min) / xAxis.unit;
                for (let i = 0; i <= xSteps; i++) {
                    const value = xAxis.min + i * xAxis.unit;
                    const { x } = dataToCanvas(value, yAxis.min);
                    if (x < padding.left -1 || x > canvasWidth - padding.right + 1) continue;
                    
                    ctx.beginPath();
                    ctx.moveTo(x, canvasHeight - padding.bottom);
                    ctx.lineTo(x, canvasHeight - padding.bottom + 5);
                    ctx.stroke();
                    
                    ctx.textAlign = 'center';
                    ctx.fillText(Number.isInteger(value) ? value : value.toFixed(1), x, canvasHeight - padding.bottom + 20);

                    if (i > 0) {
                        ctx.beginPath();
                        ctx.moveTo(x, canvasHeight - padding.bottom);
                        ctx.lineTo(x, padding.top);
                        ctx.stroke();
                    }
                }

                const ySteps = (yAxis.max - yAxis.min) / yAxis.unit;
                for (let i = 0; i <= ySteps; i++) {
                    const value = yAxis.min + i * yAxis.unit;
                    const { y } = dataToCanvas(xAxis.min, value);
                    if (y < padding.top - 1 || y > canvasHeight - padding.bottom + 1) continue;

                    ctx.beginPath();
                    ctx.moveTo(padding.left, y);
                    ctx.lineTo(padding.left - 5, y);
                    ctx.stroke();

                    ctx.textAlign = 'right';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(Number.isInteger(value) ? value : value.toFixed(1), padding.left - 10, y);

                    if (i > 0) {
                        ctx.beginPath();
                        ctx.moveTo(padding.left, y);
                        ctx.lineTo(canvasWidth - padding.right, y);
                        ctx.stroke();
                    }
                }
                
                ctx.strokeStyle = '#333';
                ctx.beginPath();
                ctx.moveTo(padding.left, padding.top);
                ctx.lineTo(padding.left, canvasHeight - padding.bottom);
                ctx.lineTo(canvasWidth - padding.right, canvasHeight - padding.bottom);
                ctx.stroke();

                ctx.font = 'bold 20px "Noto Sans TC"';
                ctx.textAlign = 'center';
                ctx.fillText(chartState.title, canvasWidth / 2, padding.top / 2);

                ctx.font = '16px "Noto Sans TC"';
                ctx.fillText(xAxis.label, canvasWidth / 2, canvasHeight - 10);
                
                ctx.save();
                ctx.translate(20, canvasHeight / 2);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText(yAxis.label, 0, 0);
                ctx.restore();
            }

            function drawLegend() {
                const canvasWidth = canvas.width / (window.devicePixelRatio || 1);
                let legendY = padding.top;
                
                ctx.font = '12px "Noto Sans TC"';
                
                chartState.groups.forEach(group => {
                    if (group.enabled) {
                        const legendX = canvasWidth - padding.right + 15;
                        
                        ctx.fillStyle = group.color;
                        ctx.strokeStyle = group.color;
                        ctx.lineWidth = 2;
                        ctx.beginPath();

                        switch (group.shape) {
                            case 'circle': ctx.arc(legendX, legendY, 5, 0, 2 * Math.PI); ctx.fill(); break;
                            case 'square': ctx.fillRect(legendX - 4, legendY - 4, 8, 8); break;
                            case 'triangle': ctx.moveTo(legendX, legendY - 5); ctx.lineTo(legendX + 5, legendY + 5); ctx.lineTo(legendX - 5, legendY + 5); ctx.closePath(); ctx.fill(); break;
                            case 'cross': ctx.moveTo(legendX - 4, legendY - 4); ctx.lineTo(legendX + 4, legendY + 4); ctx.moveTo(legendX + 4, legendY - 4); ctx.lineTo(legendX - 4, legendY + 4); ctx.stroke(); break;
                        }

                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'middle';
                        ctx.fillStyle = '#333';
                        ctx.fillText(group.name, legendX + 15, legendY);

                        legendY += 25;
                    }
                });
            }

            function drawSelectionBox() {
                if (selectionBox.visible) {
                    ctx.fillStyle = 'rgba(0, 120, 255, 0.2)';
                    ctx.strokeStyle = 'rgba(0, 120, 255, 0.8)';
                    ctx.lineWidth = 1;
                    const rectX = Math.min(selectionBox.startX, selectionBox.endX);
                    const rectY = Math.min(selectionBox.startY, selectionBox.endY);
                    const rectW = Math.abs(selectionBox.startX - selectionBox.endX);
                    const rectH = Math.abs(selectionBox.startY - selectionBox.endY);
                    ctx.fillRect(rectX, rectY, rectW, rectH);
                    ctx.strokeRect(rectX, rectY, rectW, rectH);
                }
            }

            function redrawCanvas() {
                const rect = canvas.parentElement.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                
                if (rect.width === 0 || rect.height === 0) return;

                canvas.width = rect.width * dpr;
                canvas.height = rect.height * dpr;
                
                ctx.scale(dpr, dpr);

                drawGridAndAxes();
                drawAllPoints();
                drawTrendlines();
                drawDataLabels(); 
                drawLegend();
                drawSelectionBox();
            }

            function getPointAtPos(posX, posY) {
                for (let i = chartState.dataPoints.length - 1; i >= 0; i--) {
                    const p = chartState.dataPoints[i];
                    if (!chartState.groups[p.groupIndex].enabled) continue;
                    
                    const pos = dataToCanvas(p.x, p.y);
                    const dist = Math.sqrt((posX - pos.x)**2 + (posY - pos.y)**2);
                    if (dist <= 10) { 
                        return i;
                    }
                }
                return -1;
            }

            function getEquationAtPos(posX, posY) {
                for (let i = 0; i < chartState.groups.length; i++) {
                    const group = chartState.groups[i];
                    const trendline = group.trendline;
                    if (group.enabled && trendline.visible && trendline.showEquation && trendline.equationBBox) {
                        const bbox = trendline.equationBBox;
                        if (posX >= bbox.x && posX <= bbox.x + bbox.width && posY >= bbox.y && posY <= bbox.y + bbox.height) {
                            return i;
                        }
                    }
                }
                return -1;
            }

            // --- 事件處理核心邏輯 ---
            function handleInteractionStart(x, y, event) {
                event.preventDefault();
                interactionMoved = false;
                dragStartPos = { x, y };
                
                draggedPointIndex = getPointAtPos(x, y);
                draggedEquationIndex = getEquationAtPos(x, y);

                if (draggedPointIndex !== -1) {
                    interactionState = 'draggingPoint';
                    const point = chartState.dataPoints[draggedPointIndex];
                    if (!event.shiftKey && !point.selected) {
                        chartState.dataPoints.forEach(p => p.selected = false);
                        point.selected = true;
                    }
                    chartState.dataPoints.forEach(p => {
                        if (p.selected) {
                            p.dragStartX = p.x;
                            p.dragStartY = p.y;
                        }
                    });
                } else if (draggedEquationIndex !== -1) {
                    interactionState = 'draggingEquation';
                    const group = chartState.groups[draggedEquationIndex];
                    const bbox = group.trendline.equationBBox;
                    const textX = group.trendline.equationPos.x !== null ? group.trendline.equationPos.x : bbox.x + bbox.width;
                    const textY = group.trendline.equationPos.y !== null ? group.trendline.equationPos.y : bbox.y + bbox.height;
                    dragStartOffset = { dx: x - textX, dy: y - textY };

                } else {
                    interactionState = 'selecting';
                    if (!event.shiftKey) {
                        chartState.dataPoints.forEach(p => p.selected = false);
                    }
                    selectionBox.startX = x;
                    selectionBox.startY = y;
                    selectionBox.endX = x;
                    selectionBox.endY = y;
                    selectionBox.visible = true;
                }
                redrawCanvas();
            }
            
            function handleInteractionMove(x, y, event) {
                if (interactionState === 'idle') {
                    // Update cursor style on hover
                    if (getEquationAtPos(x, y) !== -1) {
                        canvas.style.cursor = 'move';
                    } else if (getPointAtPos(x, y) !== -1) {
                        canvas.style.cursor = 'pointer';
                    } else {
                        canvas.style.cursor = 'crosshair';
                    }
                    return;
                }

                event.preventDefault();
                interactionMoved = true;
                
                if (interactionState === 'draggingPoint') {
                    const startDataPos = canvasToData(dragStartPos.x, dragStartPos.y);
                    const currentDataPos = canvasToData(x, y);
                    const dx = currentDataPos.x - startDataPos.x;
                    const dy = currentDataPos.y - startDataPos.y;

                    chartState.dataPoints.forEach(p => {
                        if (p.selected) {
                            p.x = p.dragStartX + dx;
                            p.y = p.dragStartY + dy;
                        }
                    });
                } else if (interactionState === 'draggingEquation') {
                    const group = chartState.groups[draggedEquationIndex];
                    group.trendline.equationPos = { x: x - dragStartOffset.dx, y: y - dragStartOffset.dy };
                } else if (interactionState === 'selecting') {
                    selectionBox.endX = x;
                    selectionBox.endY = y;
                }
                redrawCanvas();
            }
            
            function handleInteractionEnd(event) {
                if (interactionState === 'idle') return;
                event.preventDefault();
                
                if (interactionState === 'draggingPoint') {
                    const groupsToRecalculate = new Set();
                    chartState.dataPoints.forEach(p => {
                        if (p.selected) {
                            groupsToRecalculate.add(p.groupIndex);
                        }
                    });
                    groupsToRecalculate.forEach(index => {
                         if (chartState.groups[index].trendline.visible) {
                            recalculateTrendline(index);
                        }
                    });

                } else if (interactionState === 'selecting') {
                    const rectX1 = Math.min(selectionBox.startX, selectionBox.endX);
                    const rectY1 = Math.min(selectionBox.startY, selectionBox.endY);
                    const rectX2 = Math.max(selectionBox.startX, selectionBox.endX);
                    const rectY2 = Math.max(selectionBox.startY, selectionBox.endY);

                    chartState.dataPoints.forEach(p => {
                        const pos = dataToCanvas(p.x, p.y);
                        if (pos.x >= rectX1 && pos.x <= rectX2 && pos.y >= rectY1 && pos.y <= rectY2) {
                            p.selected = true;
                        }
                    });
                }

                if (!interactionMoved) { // This was a click/tap
                    if (draggedPointIndex !== -1) { // Click on an existing point
                         const point = chartState.dataPoints[draggedPointIndex];
                         if (event.shiftKey) {
                            point.selected = !point.selected;
                         } else {
                            chartState.dataPoints.forEach(p => p.selected = false);
                            point.selected = true;
                         }
                    } else if (draggedEquationIndex === -1) { // Click on empty space
                        if (!event.shiftKey) {
                            chartState.dataPoints.forEach(p => p.selected = false);
                        }
                        const dataPos = canvasToData(dragStartPos.x, dragStartPos.y);
                        if (dataPos.x >= chartState.xAxis.min && dataPos.x <= chartState.xAxis.max &&
                            dataPos.y >= chartState.yAxis.min && dataPos.y <= chartState.yAxis.max) {
                            
                            chartState.dataPoints.push({
                                x: dataPos.x,
                                y: dataPos.y,
                                groupIndex: chartState.activeGroupIndex,
                                selected: false
                            });
                             if (chartState.groups[chartState.activeGroupIndex].trendline.visible) {
                                recalculateTrendline(chartState.activeGroupIndex);
                            }
                        }
                    }
                }

                chartState.dataPoints.forEach(p => {
                    delete p.dragStartX;
                    delete p.dragStartY;
                });

                interactionState = 'idle';
                draggedPointIndex = -1;
                draggedEquationIndex = -1;
                selectionBox.visible = false;
                redrawCanvas();
            }

            // --- 事件監聽 ---
            applyBtn.addEventListener('click', () => {
                const xMin = parseFloat(xAxisMinInput.value);
                const xMax = parseFloat(xAxisMaxInput.value);
                const yMin = parseFloat(yAxisMinInput.value);
                const yMax = parseFloat(yAxisMaxInput.value);
                const xUnit = parseFloat(xAxisUnitInput.value);
                const yUnit = parseFloat(yAxisUnitInput.value);

                if (xMin >= xMax || yMin >= yMax || xUnit <= 0 || yUnit <= 0) {
                    alert('座標軸範圍或單位設定有誤！');
                    return;
                }
                
                chartState.title = chartTitleInput.value;
                chartState.xAxis = { label: xAxisLabelInput.value, min: xMin, max: xMax, unit: xUnit };
                chartState.yAxis = { label: yAxisLabelInput.value, min: yMin, max: yMax, unit: yUnit };
                chartState.dataPoints = []; // Clear data on apply
                chartState.groups.forEach(g => {
                    g.trendline.visible = false;
                });
                initializeGroupSettings(); // Re-render buttons
                redrawCanvas();
            });
            
            showLabelsToggle.addEventListener('change', (e) => {
                chartState.showDataLabels = e.target.checked;
                redrawCanvas();
            });

            downloadBtn.addEventListener('click', () => {
                chartState.dataPoints.forEach(p => p.selected = false);
                redrawCanvas(); // Redraw without selection highlights

                const link = document.createElement('a');
                link.download = `${chartState.title.replace(/\s+/g, '_') || 'chart'}.png`;
                link.href = canvas.toDataURL('image/png');
                link.click();
            });

            downloadDataBtn.addEventListener('click', () => {
                let csvContent = "data:text/csv;charset=utf-8,組別,X軸數值,Y軸數值\n";
                chartState.dataPoints.forEach(p => {
                    const groupName = chartState.groups[p.groupIndex].name;
                    csvContent += `${groupName},${p.x.toFixed(3)},${p.y.toFixed(3)}\n`;
                });
                const encodedUri = encodeURI(csvContent);
                const link = document.createElement('a');
                link.setAttribute('href', encodedUri);
                link.setAttribute('download', `${chartState.title.replace(/\s+/g, '_') || 'chart_data'}.csv`);
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            });
            
            // 滑鼠事件
            canvas.addEventListener('mousedown', (e) => handleInteractionStart(e.offsetX, e.offsetY, e));
            canvas.addEventListener('mousemove', (e) => handleInteractionMove(e.offsetX, e.offsetY, e));
            window.addEventListener('mouseup', (e) => handleInteractionEnd(e));

            // 觸控事件
            canvas.addEventListener('touchstart', (e) => {
                const rect = canvas.getBoundingClientRect();
                const touch = e.touches[0];
                handleInteractionStart(touch.clientX - rect.left, touch.clientY - rect.top, e);
            });
            canvas.addEventListener('touchmove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const touch = e.touches[0];
                handleInteractionMove(touch.clientX - rect.left, touch.clientY - rect.top, e);
            });
            canvas.addEventListener('touchend', (e) => handleInteractionEnd(e));
            canvas.addEventListener('touchcancel', (e) => handleInteractionEnd(e));


            document.addEventListener('keydown', (e) => {
                if (e.key === 'Delete' || e.key === 'Backspace') {
                    const groupsToRecalculate = new Set();
                    chartState.dataPoints.forEach(p => {
                        if (p.selected) {
                            groupsToRecalculate.add(p.groupIndex);
                        }
                    });

                    chartState.dataPoints = chartState.dataPoints.filter(p => !p.selected);

                    groupsToRecalculate.forEach(groupIndex => {
                        if (chartState.groups[groupIndex].trendline.visible) {
                            recalculateTrendline(groupIndex);
                        }
                    });
                    redrawCanvas();
                }
            });
            
            window.addEventListener('resize', redrawCanvas);

            // --- 初始啟動 ---
            initializeGroupSettings();
            setTimeout(() => {
                applyBtn.click();
            }, 100);
        });
    </script>

</body>
</html>

