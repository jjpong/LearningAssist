<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¯¦é©—æ•¸æ“šåœ–è¡¨å·¥å…· V27</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft JhengHei', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            overflow: hidden;
        }

        .section {
            margin: 20px;
            padding: 20px;
            border: 2px solid #e1f5fe;
            border-radius: 10px;
            background: #f8fbff;
            position: relative;
        }

        .section-title {
            display: flex;
            align-items: center;
            font-size: 18px;
            font-weight: bold;
            color: #1976d2;
            margin-bottom: 15px;
        }

        .section-title::before {
            content: "";
            width: 20px;
            height: 20px;
            margin-right: 10px;
            background-size: contain;
        }

        .axis-section .section-title::before {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%231976d2' viewBox='0 0 24 24'%3E%3Cpath d='M9 17H7v-7h2v7zm4 0h-2V7h2v10zm4 0h-2v-4h2v4zm2.5 2.25l1.25-1.25L12 9.5 9.5 12 3.75 6.25 2.5 7.5 9.5 14.5l2.5-2.5 8.5 8.5z'/%3E%3C/svg%3E");
        }

        .experiment-section .section-title::before {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23388e3c' viewBox='0 0 24 24'%3E%3Cpath d='M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0L19.2 12l-4.6-4.6L16 6l6 6-6 6-1.4-1.4z'/%3E%3C/svg%3E");
        }

        .data-section .section-title::before {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23f57c00' viewBox='0 0 24 24'%3E%3Cpath d='M3 3v18h18V3H3zm16 16H5V5h14v14zm-8-2h2v-4h4v-2h-4V7h-2v4H7v2h4v4z'/%3E%3C/svg%3E");
        }

        .chart-section .section-title::before {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%237b1fa2' viewBox='0 0 24 24'%3E%3Cpath d='M19 3H5c-1.1 0-2-.9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 17H7v-7h2v7zm4 0h-2V7h2v10zm4 0h-2v-4h2v4z'/%3E%3C/svg%3E");
        }

        .form-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
        }

        label {
            font-weight: bold;
            margin-bottom: 5px;
            color: #333;
        }

        input[type="text"], input[type="number"] {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        input[type="text"]:focus, input[type="number"]:focus {
            outline: none;
            border-color: #2196f3;
        }

        .experiment-group {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
        }

        .experiment-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .group-name {
            font-weight: bold;
            cursor: pointer;
            padding: 5px 10px;
            border-radius: 5px;
            transition: background-color 0.3s;
            min-width: 100px;
            border: 2px dashed transparent;
        }

        .group-name:hover {
            background-color: #f0f0f0;
            border-color: #2196f3;
        }

        .group-name-editing {
            background-color: #fff3e0;
            border-color: #ff9800;
        }

        .color-picker {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .color-swatch {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid #ddd;
        }

        .point-style {
            padding: 5px 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background: white;
            cursor: pointer;
            color: black;
        }

        .delete-group {
            background: #f44336;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .delete-group:hover {
            background: #d32f2f;
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }

        .data-table th {
            background: linear-gradient(135deg, #42a5f5, #1e88e5);
            color: white;
            padding: 12px;
            text-align: center;
            border-right: 1px solid rgba(255,255,255,0.3);
        }

        .data-table th:first-child {
            background: #37474f;
        }

        .data-table td {
            padding: 8px;
            text-align: center;
            border: 1px solid #ddd;
        }

        .data-table input {
            width: 100%;
            padding: 5px;
            border: none;
            text-align: center;
            background: transparent;
        }

        .data-table input:focus {
            background: #fff3e0;
            outline: 2px solid #ff9800;
            border-radius: 3px;
        }

        .editable-cell {
            cursor: pointer;
            padding: 8px;
            border-radius: 3px;
            transition: background-color 0.3s;
            border: 2px dashed transparent;
            color: black;
            font-weight: bold;
        }

        .editable-cell:hover {
            background-color: #e3f2fd;
            border-color: #2196f3;
        }

        .editable-cell-editing {
            background-color: #fff3e0;
            border-color: #ff9800;
        }

        .control-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #2196f3, #1976d2);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(33, 150, 243, 0.4);
        }

        .btn-success {
            background: linear-gradient(135deg, #4caf50, #388e3c);
            color: white;
        }

        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(76, 175, 80, 0.4);
        }

        .btn-danger {
            background: linear-gradient(135deg, #f44336, #d32f2f);
            color: white;
        }

        .btn-purple {
            background: linear-gradient(135deg, #9c27b0, #7b1fa2);
            color: white;
        }

        .btn-purple:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(156, 39, 176, 0.4);
        }

        .chart-controls {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            border: 1px solid #dee2e6;
        }

        .toggle-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .toggle-group select {
            padding: 8px 12px;
            border-radius: 6px;
            border: 2px solid #ddd;
            background: white;
            font-size: 14px;
            min-width: 180px;
            cursor: pointer;
            transition: border-color 0.3s;
        }

        .toggle-group select:focus {
            outline: none;
            border-color: #2196f3;
        }

        .toggle {
            position: relative;
            width: 50px;
            height: 25px;
            background: #ccc;
            border-radius: 25px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .toggle.active {
            background: #2196f3;
        }

        .toggle::after {
            content: '';
            position: absolute;
            width: 21px;
            height: 21px;
            background: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: transform 0.3s;
        }

        .toggle.active::after {
            transform: translateX(25px);
        }

        .chart-container {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow-x: auto;
        }

        .chart-container canvas {
            max-width: 100%;
            height: auto !important;
        }

        @media (max-width: 768px) {
            .chart-container {
                padding: 10px;
            }
        }

        .formula-display {
            background: #f5f5f5;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            font-family: 'Courier New', monospace;
        }

        .formula-group {
            margin-bottom: 10px;
            padding: 10px;
            background: white;
            border-radius: 5px;
            border-left: 4px solid #2196f3;
        }

        .inline-edit-input {
            border: 2px solid #ff9800;
            border-radius: 4px;
            padding: 4px 8px;
            font-weight: bold;
            background: #fff3e0;
            color: #333;
            min-width: 100px;
            text-align: center;
        }

        .edit-hint {
            font-size: 12px;
            color: #666;
            margin-top: 4px;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- åº§æ¨™è»¸è¨­å®š -->
        <div class="section axis-section">
            <div class="section-title">ğŸ“Š åº§æ¨™è»¸è¨­å®š</div>
            <div class="form-grid">
                <div class="form-group">
                    <label for="xAxisName">Xè»¸åç¨±</label>
                    <input type="text" id="xAxisName" name="xAxisName" value="Xè»¸" placeholder="è¼¸å…¥Xè»¸åç¨±" onchange="updateChart()">
                </div>
                <div class="form-group">
                    <label for="xAxisMin">Xè»¸æœ€å°å€¼</label>
                    <input type="number" id="xAxisMin" name="xAxisMin" value="0" onchange="updateChart()">
                </div>
                <div class="form-group">
                    <label for="xAxisMax">Xè»¸æœ€å¤§å€¼</label>
                    <input type="number" id="xAxisMax" name="xAxisMax" value="100" onchange="updateChart()">
                </div>
                <div class="form-group">
                    <label for="yAxisName">Yè»¸åç¨±</label>
                    <input type="text" id="yAxisName" name="yAxisName" value="Yè»¸" placeholder="è¼¸å…¥Yè»¸åç¨±" onchange="updateChart()">
                </div>
                <div class="form-group">
                    <label for="yAxisMin">Yè»¸æœ€å°å€¼</label>
                    <input type="number" id="yAxisMin" name="yAxisMin" value="0" onchange="updateChart()">
                </div>
                <div class="form-group">
                    <label for="yAxisMax">Yè»¸æœ€å¤§å€¼</label>
                    <input type="number" id="yAxisMax" name="yAxisMax" value="100" onchange="updateChart()">
                </div>
            </div>
        </div>

        <!-- å¯¦é©—çµ„åˆ¥ç®¡ç† -->
        <div class="section experiment-section">
            <div class="section-title">ğŸ§ª å¯¦é©—çµ„åˆ¥ç®¡ç†</div>
            <div id="experimentGroups">
                <!-- å¯¦é©—çµ„æœƒå‹•æ…‹ç”Ÿæˆ -->
            </div>
            <button class="btn btn-primary" onclick="addExperimentGroup()">
                â• æ–°å¢å¯¦é©—çµ„
            </button>
        </div>

        <!-- æ•¸æ“šè¼¸å…¥ -->
        <div class="section data-section">
            <div class="section-title">ğŸ“ æ•¸æ“šè¼¸å…¥</div>
            <table class="data-table" id="dataTable">
                <!-- è¡¨æ ¼æœƒå‹•æ…‹ç”Ÿæˆ -->
            </table>
            <div class="control-buttons">
                <button class="btn btn-success" onclick="addDataPoint()">â• æ–°å¢æ•¸æ“šé»</button>
                <button class="btn btn-danger" onclick="removeDataColumn()">â– åˆªé™¤å¯¦é©—çµ„</button>
                <button class="btn btn-purple" onclick="generateChart()">ğŸ“Š ç”Ÿæˆåœ–è¡¨</button>
            </div>
        </div>

        <!-- åœ–è¡¨æ§åˆ¶ -->
        <div class="section chart-section">
            <div class="section-title">ğŸ“ˆ åœ–è¡¨æ§åˆ¶</div>
            <div class="chart-controls">
                <div class="toggle-group">
                    <span id="trendLineLabel">é¡¯ç¤ºè¿´æ­¸ç›´ç·šï¼š</span>
                    <div class="toggle" id="trendLineToggle" onclick="toggleTrendLine()"></div>
                </div>
                <div class="toggle-group">
                    <span>é¡¯ç¤ºå…¬å¼ï¼š</span>
                    <div class="toggle" id="formulaToggle" onclick="toggleFormula()"></div>
                </div>
                <div class="toggle-group">
                    <span><strong>åœ–è¡¨é¡å‹ï¼š</strong></span>
                    <select id="chartType" name="chartType" onchange="changeChartType()">
                        <option value="linear">ğŸ“ˆ ç·šæ€§åœ–</option>
                        <option value="semilogx">ğŸ“Š åŠå°æ•¸åœ– (Xè»¸å°æ•¸)</option>
                        <option value="semilogy">ğŸ“‰ åŠå°æ•¸åœ– (Yè»¸å°æ•¸)</option>
                        <option value="loglog">ğŸ“‹ é›™å°æ•¸åœ–</option>
                    </select>
                </div>
                <button class="btn btn-purple" onclick="downloadChart()">ğŸ’¾ ä¸‹è¼‰åœ–è¡¨</button>
            </div>
            
            <div class="chart-container">
                <div class="chart-wrapper">
                    <canvas id="chart"></canvas>
                </div>
            </div>

            <div id="formulaDisplay" class="formula-display" style="display: none;">
                <h4>ğŸ“ å›æ­¸å…¬å¼</h4>
                <div id="formulaContent"></div>
            </div>
        </div>
    </div>

    <script>
        // å…¨å±€è®Šæ•¸å®£å‘Š
        let chart = null;
        let experimentGroups = [];
        let dataPoints = 5;
        let showTrendLine = false;
        let showFormula = false;
        let chartType = 'linear';
        let manipulatedVariableName = 'Xè»¸æ•¸å€¼(æ“ç¸±è®Šå› )';

        // é¡è‰²é¸é …
        const colors = [
            '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57',
            '#FF9FF3', '#54A0FF', '#5F27CD', '#00D2D3', '#FF9F43',
            '#A55EEA', '#26DE81', '#FD79A8', '#FDCB6E', '#6C5CE7'
        ];

        // é»æ¨£å¼é¸é …
        const pointStyles = ['circle', 'rect', 'triangle', 'rectRot'];

        // åˆå§‹åŒ– - ç¢ºä¿å®Œå…¨ç©ºç™½é–‹å§‹
        function init() {
            // å»ºç«‹ç¬¬ä¸€å€‹å¯¦é©—çµ„ï¼Œæ•¸æ“šå®Œå…¨ç©ºç™½
            const group = {
                id: Date.now(),
                name: 'å¯¦é©—çµ„ 1',
                color: colors[0],
                pointStyle: 'circle',
                data: ['', '', '', '', '']  // 5å€‹ç©ºç™½æ•¸æ“šé»
            };
            experimentGroups = [group];  // é‡æ–°è¨­å®šé™£åˆ—
            dataPoints = 5;
            
            updateTrendLineLabel();
            renderExperimentGroups();
            createCleanDataTable();  // ä½¿ç”¨æ–°çš„ä¹¾æ·¨è¡¨æ ¼å‡½æ•¸
            generateChart();
        }
        
        // å‰µå»ºå®Œå…¨ä¹¾æ·¨çš„æ•¸æ“šè¡¨æ ¼
        function createCleanDataTable() {
            const table = document.getElementById('dataTable');
            table.innerHTML = '';

            // å‰µå»ºè¡¨é ­
            const headerRow = table.insertRow();
            headerRow.insertCell().innerHTML = '<strong>å¯¦é©—çµ„åˆ—</strong>';
            for (let i = 0; i < dataPoints; i++) {
                headerRow.insertCell().innerHTML = `<strong>æ•¸æ“šé» ${i + 1}</strong>`;
            }

            // Xè»¸æ•¸å€¼è¡Œ - å®Œå…¨ç©ºç™½
            const xRow = table.insertRow();
            const xHeaderCell = xRow.insertCell();
            xHeaderCell.innerHTML = `<div class="editable-cell" onclick="startInlineEdit(this, 0, 'variable')">${manipulatedVariableName}</div>`;
            xHeaderCell.style.cursor = 'pointer';
            
            for (let i = 0; i < dataPoints; i++) {
                const cell = xRow.insertCell();
                cell.innerHTML = `<input type="number" id="x_${i}" name="x_${i}" value="" placeholder="" onchange="updateChart()">`;
            }

            // å„å¯¦é©—çµ„è¡Œ - å®Œå…¨ç©ºç™½
            experimentGroups.forEach((group, groupIndex) => {
                const row = table.insertRow();
                const nameCell = row.insertCell();
                nameCell.innerHTML = `<div class="editable-cell" onclick="startInlineEdit(this, ${groupIndex}, 'group')">${group.name}</div>`;
                nameCell.style.backgroundColor = group.color;
                nameCell.style.color = 'white';
                nameCell.style.fontWeight = 'bold';
                nameCell.style.cursor = 'pointer';

                for (let i = 0; i < dataPoints; i++) {
                    const cell = row.insertCell();
                    cell.innerHTML = `<input type="number" id="y_${groupIndex}_${i}" name="y_${groupIndex}_${i}" value="" onchange="updateGroupData(${groupIndex}, ${i}, this.value)">`;
                }
            });
        }

        // æ–°å¢å¯¦é©—çµ„ - ä¿®å¾©ç‰ˆæœ¬ï¼Œé¿å…è§¸ç™¼é è¼‰å€¼
        function addExperimentGroup(name = '', color = '', pointStyle = 'circle') {
            const groupIndex = experimentGroups.length;
            const groupName = name || `å¯¦é©—çµ„ ${groupIndex + 1}`;
            const groupColor = color || colors[groupIndex % colors.length];
            const groupPointStyle = pointStyle || pointStyles[groupIndex % pointStyles.length];
            
            const group = {
                id: Date.now() + groupIndex,
                name: groupName,
                color: groupColor,
                pointStyle: groupPointStyle,
                data: Array(dataPoints).fill('')  // ç¢ºä¿æ–°çµ„çš„æ•¸æ“šä¹Ÿæ˜¯ç©ºç™½
            };
            
            experimentGroups.push(group);
            renderExperimentGroups();
            
            // ä¸èª¿ç”¨updateDataTable()ï¼Œè€Œæ˜¯æ‰‹å‹•æ·»åŠ æ–°çš„å¯¦é©—çµ„è¡Œ
            addExperimentGroupRowToTable(group, groupIndex);
            generateChart();
        }

        // æ‰‹å‹•æ·»åŠ å¯¦é©—çµ„è¡Œåˆ°è¡¨æ ¼ï¼Œä¿ç•™ç¾æœ‰æ•¸æ“š
        function addExperimentGroupRowToTable(group, groupIndex) {
            const table = document.getElementById('dataTable');
            
            // æ·»åŠ æ–°çš„å¯¦é©—çµ„è¡Œ
            const row = table.insertRow();
            const nameCell = row.insertCell();
            nameCell.innerHTML = `<div class="editable-cell" onclick="startInlineEdit(this, ${groupIndex}, 'group')">${group.name}</div>`;
            nameCell.style.backgroundColor = group.color;
            nameCell.style.color = 'white';
            nameCell.style.fontWeight = 'bold';
            nameCell.style.cursor = 'pointer';

            // ç‚ºæ–°å¯¦é©—çµ„æ·»åŠ æ•¸æ“šè¼¸å…¥æ¬„ä½ï¼Œå…¨éƒ¨ç©ºç™½
            for (let i = 0; i < dataPoints; i++) {
                const cell = row.insertCell();
                cell.innerHTML = `<input type="number" id="y_${groupIndex}_${i}" name="y_${groupIndex}_${i}" value="" placeholder="è¼¸å…¥æ•¸å€¼" onchange="updateGroupData(${groupIndex}, ${i}, this.value)">`;
            }
        }

        // æ¸²æŸ“å¯¦é©—çµ„ - ä¿®å¾©ç‰ˆæœ¬ï¼Œé¿å…ç›´æ¥ä½¿ç”¨onclick
        function renderExperimentGroups() {
            const container = document.getElementById('experimentGroups');
            container.innerHTML = '';

            experimentGroups.forEach((group, index) => {
                const groupDiv = document.createElement('div');
                groupDiv.className = 'experiment-group';
                groupDiv.innerHTML = `
                    <div class="experiment-header">
                        <span class="group-name" onclick="startInlineEdit(this, ${index}, 'group')">${group.name}</span>
                        <div class="color-picker">
                            <div class="color-swatch" style="background-color: ${group.color}" onclick="changeGroupColor(${index})"></div>
                            <select class="point-style" name="pointStyle_${index}" onchange="changePointStyle(${index}, this.value)">
                                <option value="circle" ${group.pointStyle === 'circle' ? 'selected' : ''}>åœ“å½¢</option>
                                <option value="rect" ${group.pointStyle === 'rect' ? 'selected' : ''}>æ–¹å½¢</option>
                                <option value="triangle" ${group.pointStyle === 'triangle' ? 'selected' : ''}>ä¸‰è§’å½¢</option>
                                <option value="rectRot" ${group.pointStyle === 'rectRot' ? 'selected' : ''}>è±å½¢</option>
                            </select>
                            ${experimentGroups.length > 1 ? `<button class="delete-group" data-group-index="${index}">åˆªé™¤</button>` : ''}
                        </div>
                    </div>
                    <div class="edit-hint">é»æ“Šçµ„åˆ¥åç¨±å¯ç·¨è¼¯</div>
                `;
                container.appendChild(groupDiv);
            });
            
            // ç‚ºæ‰€æœ‰åˆªé™¤æŒ‰éˆ•ç¶å®šäº‹ä»¶è™•ç†å™¨
            const deleteButtons = container.querySelectorAll('.delete-group');
            deleteButtons.forEach(button => {
                button.addEventListener('click', function() {
                    const groupIndex = parseInt(this.dataset.groupIndex);
                    console.log(`=== è§¸ç™¼åˆªé™¤å¯¦é©—çµ„ ${groupIndex} ===`);
                    
                    if (experimentGroups.length > 1) {
                        // ä¿å­˜æ‰€æœ‰ç¾æœ‰æ•¸æ“š
                        const currentXValues = [];
                        for (let i = 0; i < dataPoints; i++) {
                            const input = document.getElementById(`x_${i}`);
                            currentXValues[i] = input ? input.value : '';
                        }
                        
                        const currentGroupValues = [];
                        experimentGroups.forEach((group, gIndex) => {
                            if (gIndex !== groupIndex) { // è·³éè¦åˆªé™¤çš„çµ„
                                currentGroupValues.push([]);
                                for (let i = 0; i < dataPoints; i++) {
                                    const input = document.getElementById(`y_${gIndex}_${i}`);
                                    currentGroupValues[currentGroupValues.length - 1][i] = input ? input.value : '';
                                }
                            }
                        });
                        
                        // ç§»é™¤æŒ‡å®šçš„å¯¦é©—çµ„
                        experimentGroups.splice(groupIndex, 1);
                        renderExperimentGroups();
                        
                        // é‡å»ºè¡¨æ ¼ä½†ä¿ç•™æ•¸æ“š
                        rebuildTableWithSavedData(currentXValues, currentGroupValues);
                        generateChart();
                        
                        console.log('=== åˆªé™¤å®Œæˆ ===');
                    }
                });
            });
        }

        // ä½¿ç”¨ä¿å­˜çš„æ•¸æ“šé‡å»ºè¡¨æ ¼
        function rebuildTableWithSavedData(savedXValues, savedGroupValues) {
            const table = document.getElementById('dataTable');
            table.innerHTML = '';

            // å‰µå»ºè¡¨é ­
            const headerRow = table.insertRow();
            headerRow.insertCell().innerHTML = '<strong>å¯¦é©—çµ„åˆ—</strong>';
            for (let i = 0; i < dataPoints; i++) {
                headerRow.insertCell().innerHTML = `<strong>æ•¸æ“šé» ${i + 1}</strong>`;
            }

            // Xè»¸æ•¸å€¼è¡Œ
            const xRow = table.insertRow();
            const xHeaderCell = xRow.insertCell();
            xHeaderCell.innerHTML = `<div class="editable-cell" onclick="startInlineEdit(this, 0, 'variable')">${manipulatedVariableName}</div>`;
            xHeaderCell.style.cursor = 'pointer';
            
            for (let i = 0; i < dataPoints; i++) {
                const cell = xRow.insertCell();
                const value = i < savedXValues.length ? savedXValues[i] : '';
                cell.innerHTML = `<input type="number" id="x_${i}" name="x_${i}" value="${value}" placeholder="è¼¸å…¥æ•¸å€¼" onchange="updateChart()">`;
            }

            // å„å¯¦é©—çµ„è¡Œ
            experimentGroups.forEach((group, groupIndex) => {
                const row = table.insertRow();
                const nameCell = row.insertCell();
                nameCell.innerHTML = `<div class="editable-cell" onclick="startInlineEdit(this, ${groupIndex}, 'group')">${group.name}</div>`;
                nameCell.style.backgroundColor = group.color;
                nameCell.style.color = 'white';
                nameCell.style.fontWeight = 'bold';
                nameCell.style.cursor = 'pointer';

                for (let i = 0; i < dataPoints; i++) {
                    const cell = row.insertCell();
                    const value = (savedGroupValues[groupIndex] && i < savedGroupValues[groupIndex].length) ? savedGroupValues[groupIndex][i] : '';
                    cell.innerHTML = `<input type="number" id="y_${groupIndex}_${i}" name="y_${groupIndex}_${i}" value="${value}" placeholder="è¼¸å…¥æ•¸å€¼" onchange="updateGroupData(${groupIndex}, ${i}, this.value)">`;
                }
            });
        }

        // é–‹å§‹ç›´æ¥ç·¨è¼¯æ¨¡å¼ - æ”¯æ´åç¨±åŒæ­¥çš„ä¿®å¾©ç‰ˆæœ¬
        function startInlineEdit(element, index, type) {
            if (element.querySelector('input')) return; // å·²åœ¨ç·¨è¼¯ç‹€æ…‹

            const currentText = element.textContent;
            element.innerHTML = `<input type="text" class="inline-edit-input" value="${currentText}" maxlength="20">`;
            
            const input = element.querySelector('input');
            input.focus();
            input.select();
            
            element.classList.add('editable-cell-editing');

            // è™•ç†ç¢ºèªç·¨è¼¯
            const confirmEdit = () => {
                const newText = input.value.trim();
                if (newText && newText !== currentText) {
                    if (type === 'group') {
                        experimentGroups[index].name = newText;
                        // åŒæ­¥æ›´æ–°æ‰€æœ‰é¡¯ç¤ºè©²çµ„åˆ¥åç¨±çš„åœ°æ–¹
                        syncGroupNameDisplay(index, newText);
                        generateChart(); // åªæ›´æ–°åœ–è¡¨
                        return;
                    } else if (type === 'variable') {
                        manipulatedVariableName = newText;
                        // åŒæ­¥æ›´æ–°æ‰€æœ‰é¡¯ç¤ºæ“ç¸±è®Šå› åç¨±çš„åœ°æ–¹
                        syncVariableNameDisplay(newText);
                        generateChart(); // åªæ›´æ–°åœ–è¡¨
                        return;
                    }
                }
                element.textContent = newText || currentText;
                element.classList.remove('editable-cell-editing');
            };

            // Enteréµç¢ºèª
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    confirmEdit();
                }
            });

            // å¤±ç„¦ç¢ºèª
            input.addEventListener('blur', confirmEdit);
        }

        // åŒæ­¥çµ„åˆ¥åç¨±é¡¯ç¤º - æ›´æ–°æ‰€æœ‰ç›¸é—œä½ç½®
        function syncGroupNameDisplay(groupIndex, newName) {
            // æ›´æ–°å¯¦é©—çµ„ç®¡ç†å€åŸŸçš„åç¨±
            const groupElements = document.querySelectorAll('.group-name');
            if (groupElements[groupIndex]) {
                groupElements[groupIndex].textContent = newName + ' (é»æ“Šç·¨è¼¯åç¨±)';
            }
            
            // æ›´æ–°æ•¸æ“šè¡¨æ ¼ä¸­çš„åç¨± (è¡¨æ ¼çš„è¡Œåç¨±)
            const tableRows = document.querySelectorAll('#dataTable tr');
            // è·³éè¡¨é ­è¡Œå’ŒXè»¸è¡Œï¼Œæ‰¾åˆ°å°æ‡‰çš„å¯¦é©—çµ„è¡Œ
            const targetRow = tableRows[groupIndex + 2]; // +2 å› ç‚ºå‰é¢æœ‰è¡¨é ­å’ŒXè»¸è¡Œ
            if (targetRow) {
                const nameCell = targetRow.querySelector('.editable-cell');
                if (nameCell) {
                    nameCell.textContent = newName;
                }
            }
        }

        // åŒæ­¥æ“ç¸±è®Šå› åç¨±é¡¯ç¤º - æ›´æ–°æ‰€æœ‰ç›¸é—œä½ç½®
        function syncVariableNameDisplay(newName) {
            // æ›´æ–°æ‰€æœ‰é¡¯ç¤ºæ“ç¸±è®Šå› åç¨±çš„åœ°æ–¹
            const variableElements = document.querySelectorAll('#dataTable .editable-cell');
            if (variableElements[0]) { // ç¬¬ä¸€å€‹æ‡‰è©²æ˜¯Xè»¸çš„åç¨±
                variableElements[0].textContent = newName;
            }
        }

        // æ›´æ”¹çµ„åˆ¥é¡è‰²
        function changeGroupColor(index) {
            const input = document.createElement('input');
            input.type = 'color';
            input.value = experimentGroups[index].color;
            input.onchange = function() {
                experimentGroups[index].color = this.value;
                renderExperimentGroups();
                generateChart();
            };
            input.click();
        }

        // æ›´æ”¹é»æ¨£å¼
        function changePointStyle(index, style) {
            experimentGroups[index].pointStyle = style;
            generateChart();
        }

        // ç§»é™¤å¯¦é©—çµ„
        function removeExperimentGroup(index) {
            if (experimentGroups.length > 1) {
                experimentGroups.splice(index, 1);
                renderExperimentGroups();
                updateDataTable();
                generateChart();
            }
        }

        // æ›´æ–°æ•¸æ“šè¡¨æ ¼
        function updateDataTable() {
            const table = document.getElementById('dataTable');
            table.innerHTML = '';

            // å‰µå»ºè¡¨é ­
            const headerRow = table.insertRow();
            headerRow.insertCell().innerHTML = '<strong>å¯¦é©—çµ„åˆ—</strong>';
            for (let i = 0; i < dataPoints; i++) {
                headerRow.insertCell().innerHTML = `<strong>æ•¸æ“šé» ${i + 1}</strong>`;
            }

            // Xè»¸æ•¸å€¼è¡Œ
            const xRow = table.insertRow();
            const xHeaderCell = xRow.insertCell();
            xHeaderCell.innerHTML = `<div class="editable-cell" onclick="startInlineEdit(this, 0, 'variable')">${manipulatedVariableName}</div>`;
            xHeaderCell.style.cursor = 'pointer';
            
            for (let i = 0; i < dataPoints; i++) {
                const cell = xRow.insertCell();
                const savedValue = getXValue(i);
                cell.innerHTML = `<input type="number" id="x_${i}" name="x_${i}" value="${savedValue}" onchange="updateChart()">`;
            }

            // å„å¯¦é©—çµ„è¡Œ
            experimentGroups.forEach((group, groupIndex) => {
                const row = table.insertRow();
                const nameCell = row.insertCell();
                nameCell.innerHTML = `<div class="editable-cell" onclick="startInlineEdit(this, ${groupIndex}, 'group')">${group.name}</div>`;
                nameCell.style.backgroundColor = group.color;
                nameCell.style.color = 'white';
                nameCell.style.fontWeight = 'bold';
                nameCell.style.cursor = 'pointer';

                for (let i = 0; i < dataPoints; i++) {
                    const cell = row.insertCell();
                    cell.innerHTML = `<input type="number" id="y_${groupIndex}_${i}" name="y_${groupIndex}_${i}" value="${group.data[i]}" onchange="updateGroupData(${groupIndex}, ${i}, this.value)">`;
                }
            });
        }

        // ç²å–Xå€¼ (é¿å…é‡ç½®ç‚ºé è¨­å€¼)
        function getXValue(index) {
            const existingInput = document.getElementById(`x_${index}`);
            if (existingInput && existingInput.value) {
                return existingInput.value;
            }
            // åªåœ¨çœŸæ­£æ²’æœ‰å€¼æ™‚æ‰ä½¿ç”¨é è¨­å€¼
            return index === 0 ? '10' : (parseInt(getXValue(index - 1)) + 10).toString();
        }

        // æ›´æ–°çµ„åˆ¥æ•¸æ“š
        function updateGroupData(groupIndex, pointIndex, value) {
            experimentGroups[groupIndex].data[pointIndex] = value;
            if (showFormula) {
                calculateAndDisplayFormulas();
            }
        }

        // æ–°å¢æ•¸æ“šé»
        function addDataPoint() {
            dataPoints++;
            experimentGroups.forEach(group => {
                group.data.push('');
            });
            updateDataTable();
            generateChart();
        }

        // ç§»é™¤æ•¸æ“šæ¬„
        function removeDataColumn() {
            if (experimentGroups.length > 1) {
                experimentGroups.pop();
                renderExperimentGroups();
                updateDataTable();
                generateChart();
            }
        }

        // åˆ‡æ›åœ–è¡¨é¡å‹
        function changeChartType() {
            chartType = document.getElementById('chartType').value;
            updateTrendLineLabel();
            generateChart();
        }

        // æ›´æ–°è¶¨å‹¢ç·šæ¨™ç±¤
        function updateTrendLineLabel() {
            const label = document.getElementById('trendLineLabel');
            if (!label) return;
            
            switch(chartType) {
                case 'linear':
                    label.textContent = 'é¡¯ç¤ºè¿´æ­¸ç›´ç·šï¼š';
                    break;
                case 'semilogx':
                    label.textContent = 'é¡¯ç¤ºå°æ•¸è¿´æ­¸ç·šï¼š';
                    break;
                case 'semilogy':
                    label.textContent = 'é¡¯ç¤ºæŒ‡æ•¸è¿´æ­¸ç·šï¼š';
                    break;
                case 'loglog':
                    label.textContent = 'é¡¯ç¤ºå†ªæ¬¡è¿´æ­¸ç·šï¼š';
                    break;
                default:
                    label.textContent = 'é¡¯ç¤ºè¿´æ­¸ç›´ç·šï¼š';
                    break;
            }
        }

        // åˆ‡æ›è¶¨å‹¢ç·š
        function toggleTrendLine() {
            showTrendLine = !showTrendLine;
            document.getElementById('trendLineToggle').classList.toggle('active', showTrendLine);
            generateChart();
        }

        // åˆ‡æ›å…¬å¼é¡¯ç¤º
        function toggleFormula() {
            showFormula = !showFormula;
            document.getElementById('formulaToggle').classList.toggle('active', showFormula);
            const formulaDisplay = document.getElementById('formulaDisplay');
            formulaDisplay.style.display = showFormula ? 'block' : 'none';
            if (showFormula) {
                calculateAndDisplayFormulas();
            }
        }

        // ç”Ÿæˆåœ–è¡¨
        function generateChart() {
            const ctx = document.getElementById('chart').getContext('2d');
            
            // å¼·åˆ¶è¨­å®šç•«å¸ƒå°ºå¯¸ (ç‰¹åˆ¥æ˜¯æ‰‹æ©Ÿç‰ˆ)
            const canvas = ctx.canvas;
            if (window.innerWidth < 768) {
                canvas.style.height = '500px';
                canvas.style.width = '100%';
            }
            
            // ç²å–åº§æ¨™è»¸è¨­å®š
            const xAxisName = document.getElementById('xAxisName').value;
            const yAxisName = document.getElementById('yAxisName').value;
            const xMin = parseFloat(document.getElementById('xAxisMin').value);
            const xMax = parseFloat(document.getElementById('xAxisMax').value);
            const yMin = parseFloat(document.getElementById('yAxisMin').value);
            const yMax = parseFloat(document.getElementById('yAxisMax').value);

            // æº–å‚™æ•¸æ“š
            const datasets = [];

            experimentGroups.forEach((group, index) => {
                const xData = [];
                const yData = [];

                for (let i = 0; i < dataPoints; i++) {
                    const xInput = document.getElementById(`x_${i}`);
                    const yInput = document.getElementById(`y_${index}_${i}`);
                    
                    if (xInput && yInput && xInput.value && yInput.value) {
                        let x = parseFloat(xInput.value);
                        let y = parseFloat(yInput.value);
                        
                        // å°æ•¸è½‰æ›æª¢æŸ¥ - ç¢ºä¿æ•¸å€¼ç‚ºæ­£
                        if ((chartType === 'semilogx' || chartType === 'loglog') && x <= 0) {
                            continue;
                        }
                        if ((chartType === 'semilogy' || chartType === 'loglog') && y <= 0) {
                            continue;
                        }
                        
                        xData.push(x);
                        yData.push(y);
                    }
                }

                if (xData.length === 0) return;

                const pointData = xData.map((x, i) => ({ x: x, y: yData[i] }));

                // ä¸»è¦æ•¸æ“šé›†
                datasets.push({
                    label: group.name,
                    data: pointData,
                    backgroundColor: group.color,
                    borderColor: group.color,
                    pointStyle: group.pointStyle,
                    pointRadius: 8,
                    pointHoverRadius: 10,
                    showLine: false,
                    fill: false
                });

                // è¶¨å‹¢ç·š
                if (showTrendLine && pointData.length > 1) {
                    let regression;
                    let trendData = [];
                    
                    if (chartType === 'linear') {
                        regression = calculateLinearRegression(xData, yData);
                        trendData = [
                            { x: xMin, y: regression.slope * xMin + regression.intercept },
                            { x: xMax, y: regression.slope * xMax + regression.intercept }
                        ];
                    } else if (chartType === 'semilogx') {
                        const logXData = xData.map(x => Math.log10(x));
                        regression = calculateLinearRegression(logXData, yData);
                        const xValues = [];
                        for (let x = Math.max(xMin, 0.1); x <= xMax; x *= 1.5) {
                            xValues.push(x);
                        }
                        trendData = xValues.map(x => ({
                            x: x,
                            y: regression.slope * Math.log10(x) + regression.intercept
                        }));
                    } else if (chartType === 'semilogy') {
                        const logYData = yData.map(y => Math.log10(y));
                        regression = calculateLinearRegression(xData, logYData);
                        trendData = [
                            { x: xMin, y: Math.pow(10, regression.slope * xMin + regression.intercept) },
                            { x: xMax, y: Math.pow(10, regression.slope * xMax + regression.intercept) }
                        ];
                    } else if (chartType === 'loglog') {
                        const logXData = xData.map(x => Math.log10(x));
                        const logYData = yData.map(y => Math.log10(y));
                        regression = calculateLinearRegression(logXData, logYData);
                        const xValues = [];
                        for (let x = Math.max(xMin, 0.1); x <= xMax; x *= 1.5) {
                            xValues.push(x);
                        }
                        trendData = xValues.map(x => ({
                            x: x,
                            y: Math.pow(10, regression.slope * Math.log10(x) + regression.intercept)
                        }));
                    }

                    datasets.push({
                        label: `${group.name} ${getTrendLineLabel()}`,
                        data: trendData,
                        borderColor: group.color,
                        backgroundColor: 'transparent',
                        borderDash: [5, 5],
                        pointRadius: 0,
                        showLine: true,
                        fill: false
                    });
                }
            });

            // éŠ·æ¯€èˆŠåœ–è¡¨
            if (chart) {
                chart.destroy();
            }

            // è¨­å®šåº§æ¨™è»¸é¡å‹
            const xAxisConfig = {
                title: {
                    display: true,
                    text: xAxisName + (chartType === 'semilogx' || chartType === 'loglog' ? ' (å°æ•¸å°ºåº¦)' : ''),
                    font: { size: 14, weight: 'bold' }
                },
                grid: {
                    color: 'rgba(0,0,0,0.1)'
                }
            };

            const yAxisConfig = {
                title: {
                    display: true,
                    text: yAxisName + (chartType === 'semilogy' || chartType === 'loglog' ? ' (å°æ•¸å°ºåº¦)' : ''),
                    font: { size: 14, weight: 'bold' }
                },
                grid: {
                    color: 'rgba(0,0,0,0.1)'
                }
            };

            // æ ¹æ“šåœ–è¡¨é¡å‹è¨­å®šåº§æ¨™è»¸
            if (chartType === 'semilogx' || chartType === 'loglog') {
                xAxisConfig.type = 'logarithmic';
                xAxisConfig.min = Math.max(xMin, 0.1);
                xAxisConfig.max = xMax;
            } else {
                xAxisConfig.min = xMin;
                xAxisConfig.max = xMax;
            }

            if (chartType === 'semilogy' || chartType === 'loglog') {
                yAxisConfig.type = 'logarithmic';
                yAxisConfig.min = Math.max(yMin, 0.1);
                yAxisConfig.max = yMax;
            } else {
                yAxisConfig.min = yMin;
                yAxisConfig.max = yMax;
            }

            // å‰µå»ºæ–°åœ–è¡¨
            chart = new Chart(ctx, {
                type: 'scatter',
                data: { datasets: datasets },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: `å¯¦é©—æ•¸æ“šæ•£ä½ˆåœ– - ${getChartTypeLabel()}`,
                            font: { size: 18, weight: 'bold' }
                        },
                        legend: {
                            display: true,
                            position: 'top'
                        }
                    },
                    scales: {
                        x: xAxisConfig,
                        y: yAxisConfig
                    },
                    elements: {
                        point: {
                            borderWidth: 2
                        }
                    }
                }
            });

            if (showFormula) {
                calculateAndDisplayFormulas();
            }
        }

        // ç²å–è¶¨å‹¢ç·šæ¨™ç±¤
        function getTrendLineLabel() {
            switch(chartType) {
                case 'linear': return 'è¿´æ­¸ç›´ç·š';
                case 'semilogx': return 'å°æ•¸è¿´æ­¸ç·š';
                case 'semilogy': return 'æŒ‡æ•¸è¿´æ­¸ç·š';
                case 'loglog': return 'å†ªæ¬¡è¿´æ­¸ç·š';
                default: return 'è¿´æ­¸ç›´ç·š';
            }
        }

        // ç²å–åœ–è¡¨é¡å‹æ¨™ç±¤
        function getChartTypeLabel() {
            switch(chartType) {
                case 'linear': return 'ç·šæ€§åœ–';
                case 'semilogx': return 'åŠå°æ•¸åœ– (Xè»¸å°æ•¸)';
                case 'semilogy': return 'åŠå°æ•¸åœ– (Yè»¸å°æ•¸)';
                case 'loglog': return 'é›™å°æ•¸åœ–';
                default: return 'ç·šæ€§åœ–';
            }
        }

        // è¨ˆç®—ç·šæ€§å›æ­¸
        function calculateLinearRegression(xData, yData) {
            const n = xData.length;
            const sumX = xData.reduce((a, b) => a + b, 0);
            const sumY = yData.reduce((a, b) => a + b, 0);
            const sumXY = xData.reduce((sum, x, i) => sum + x * yData[i], 0);
            const sumXX = xData.reduce((sum, x) => sum + x * x, 0);

            const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;

            // è¨ˆç®— RÂ²
            const yMean = sumY / n;
            const ssRes = yData.reduce((sum, y, i) => sum + Math.pow(y - (slope * xData[i] + intercept), 2), 0);
            const ssTot = yData.reduce((sum, y) => sum + Math.pow(y - yMean, 2), 0);
            const rSquared = 1 - (ssRes / ssTot);

            return { slope, intercept, rSquared };
        }

        // è¨ˆç®—ä¸¦é¡¯ç¤ºå…¬å¼
        function calculateAndDisplayFormulas() {
            const formulaContent = document.getElementById('formulaContent');
            if (!formulaContent) return;
            
            formulaContent.innerHTML = '';
            
            // æ”¶é›†æ‰€æœ‰å¯¦é©—çµ„çš„RÂ²å€¼ç”¨æ–¼æ¯”è¼ƒ
            const allRSquared = [];

            experimentGroups.forEach((group, index) => {
                const xData = [];
                const yData = [];

                for (let i = 0; i < dataPoints; i++) {
                    const xInput = document.getElementById(`x_${i}`);
                    const yInput = document.getElementById(`y_${index}_${i}`);
                    
                    if (xInput && yInput && xInput.value && yInput.value) {
                        let x = parseFloat(xInput.value);
                        let y = parseFloat(yInput.value);
                        
                        // å°æ•¸è½‰æ›æª¢æŸ¥
                        if ((chartType === 'semilogx' || chartType === 'loglog') && x <= 0) continue;
                        if ((chartType === 'semilogy' || chartType === 'loglog') && y <= 0) continue;
                        
                        xData.push(x);
                        yData.push(y);
                    }
                }

                if (xData.length > 1) {
                    let regression;
                    let formulaText = '';
                    
                    if (chartType === 'linear') {
                        regression = calculateLinearRegression(xData, yData);
                        formulaText = `y = ${regression.slope.toFixed(4)}x + ${regression.intercept.toFixed(4)}`;
                    } else if (chartType === 'semilogx') {
                        // åŠå°æ•¸Xè»¸ï¼šy = a*log(x) + b
                        const logXData = xData.map(x => Math.log10(x));
                        regression = calculateLinearRegression(logXData, yData);
                        formulaText = `y = ${regression.slope.toFixed(4)}log(x) + ${regression.intercept.toFixed(4)}`;
                    } else if (chartType === 'semilogy') {
                        // åŠå°æ•¸Yè»¸ï¼šlog(y) = a*x + bï¼Œå³ y = 10^(a*x + b)
                        const logYData = yData.map(y => Math.log10(y));
                        regression = calculateLinearRegression(xData, logYData);
                        // åœ¨å°æ•¸ç©ºé–“çš„å…¬å¼ï¼šlog(y) = slope*x + intercept
                        // è½‰æ›ç‚ºåŸå§‹ç©ºé–“ï¼šy = 10^(slope*x + intercept)
                        formulaText = `log(y) = ${regression.slope.toFixed(4)}x + ${regression.intercept.toFixed(4)}`;
                    } else if (chartType === 'loglog') {
                        // é›™å°æ•¸ï¼šlog(y) = a*log(x) + bï¼Œå³ y = 10^b * x^a
                        const logXData = xData.map(x => Math.log10(x));
                        const logYData = yData.map(y => Math.log10(y));
                        regression = calculateLinearRegression(logXData, logYData);
                        // åœ¨å°æ•¸ç©ºé–“çš„å…¬å¼ï¼šlog(y) = slope*log(x) + intercept
                        formulaText = `log(y) = ${regression.slope.toFixed(4)}log(x) + ${regression.intercept.toFixed(4)}`;
                    }
                    
                    allRSquared.push({
                        groupName: group.name,
                        rSquared: regression.rSquared,
                        chartType: chartType
                    });
                    
                    const formulaDiv = document.createElement('div');
                    formulaDiv.className = 'formula-group';
                    
                    let chartTypeLabel = '';
                    switch(chartType) {
                        case 'linear': chartTypeLabel = 'ç·šæ€§åœ–'; break;
                        case 'semilogx': chartTypeLabel = 'åŠå°æ•¸åœ– (Xè»¸å°æ•¸)'; break;
                        case 'semilogy': chartTypeLabel = 'åŠå°æ•¸åœ– (Yè»¸å°æ•¸)'; break;
                        case 'loglog': chartTypeLabel = 'é›™å°æ•¸åœ–'; break;
                        default: chartTypeLabel = 'ç·šæ€§åœ–'; break;
                    }
                    
                    // åˆ¤æ–·RÂ²å“è³ª
                    let qualityText = '';
                    let qualityColor = '';
                    if (regression.rSquared >= 0.95) {
                        qualityText = 'æ¥µä½³æ“¬åˆ';
                        qualityColor = '#4CAF50';
                    } else if (regression.rSquared >= 0.90) {
                        qualityText = 'è‰¯å¥½æ“¬åˆ';
                        qualityColor = '#8BC34A';
                    } else if (regression.rSquared >= 0.80) {
                        qualityText = 'ä¸­ç­‰æ“¬åˆ';
                        qualityColor = '#FF9800';
                    } else if (regression.rSquared >= 0.70) {
                        qualityText = 'è¼ƒå¼±é—œä¿‚';
                        qualityColor = '#FF5722';
                    } else {
                        qualityText = 'æ“¬åˆä¸ä½³';
                        qualityColor = '#F44336';
                    }
                    
                    formulaDiv.innerHTML = `
                        <div style="color: ${group.color}; font-weight: bold;">${group.name} (${chartTypeLabel}):</div>
                        <div><strong>${formulaText}</strong></div>
                        <div>RÂ² = ${regression.rSquared.toFixed(4)} 
                             <span style="color: ${qualityColor}; font-weight: bold;">(${qualityText})</span>
                        </div>
                    `;
                    formulaContent.appendChild(formulaDiv);
                }
            });
            
            // æ·»åŠ æ•´é«”åˆ†æå»ºè­° - ä¿ç•™é¡è‰²è©•ä¼°ï¼Œæ”¹é€²å¤šçµ„æ•¸æ“šçš„æ‘˜è¦
            if (allRSquared.length > 0) {
                const analysisDiv = document.createElement('div');
                analysisDiv.className = 'analysis-summary';
                analysisDiv.style.cssText = `
                    margin-top: 20px;
                    padding: 15px;
                    background: #e3f2fd;
                    border-radius: 8px;
                    border-left: 4px solid #1976d2;
                `;
                
                let analysisText = '<h4 style="color: #1976d2; margin-bottom: 10px;">ğŸ“Š åˆ†ææ‘˜è¦</h4>';
                
                // æ‰¾å‡ºæœ€é«˜å’Œæœ€ä½RÂ²å€¼
                const maxRSquared = Math.max(...allRSquared.map(item => item.rSquared));
                const minRSquared = Math.min(...allRSquared.map(item => item.rSquared));
                const bestGroup = allRSquared.find(item => item.rSquared === maxRSquared);
                
                // çµ±è¨ˆå„å“è³ªç­‰ç´šçš„æ•¸é‡
                const qualityStats = {
                    excellent: allRSquared.filter(item => item.rSquared >= 0.95).length,
                    good: allRSquared.filter(item => item.rSquared >= 0.90 && item.rSquared < 0.95).length,
                    medium: allRSquared.filter(item => item.rSquared >= 0.80 && item.rSquared < 0.90).length,
                    weak: allRSquared.filter(item => item.rSquared >= 0.70 && item.rSquared < 0.80).length,
                    poor: allRSquared.filter(item => item.rSquared < 0.70).length
                };
                
                if (allRSquared.length > 1) {
                    analysisText += `<p><strong>æ•¸æ“šæ¦‚æ³ï¼š</strong>å…± ${allRSquared.length} çµ„æ•¸æ“šï¼ŒRÂ²å€¼ç¯„åœï¼š${minRSquared.toFixed(3)} - ${maxRSquared.toFixed(3)}</p>`;
                    
                    // å“è³ªåˆ†ä½ˆçµ±è¨ˆ
                    let qualityDistribution = [];
                    if (qualityStats.excellent > 0) qualityDistribution.push(`${qualityStats.excellent}çµ„æ¥µä½³æ“¬åˆ`);
                    if (qualityStats.good > 0) qualityDistribution.push(`${qualityStats.good}çµ„è‰¯å¥½æ“¬åˆ`);
                    if (qualityStats.medium > 0) qualityDistribution.push(`${qualityStats.medium}çµ„ä¸­ç­‰æ“¬åˆ`);
                    if (qualityStats.weak > 0) qualityDistribution.push(`${qualityStats.weak}çµ„è¼ƒå¼±é—œä¿‚`);
                    if (qualityStats.poor > 0) qualityDistribution.push(`${qualityStats.poor}çµ„æ“¬åˆä¸ä½³`);
                    
                    if (qualityDistribution.length > 0) {
                        analysisText += `<p><strong>å“è³ªåˆ†ä½ˆï¼š</strong>${qualityDistribution.join('ã€')}</p>`;
                    }
                    
                    analysisText += `<p><strong>æœ€ä½³è¡¨ç¾ï¼š</strong>${bestGroup.groupName} çš„ ${getCurrentChartTypeName()}æ¨¡å‹ (RÂ² = ${maxRSquared.toFixed(3)})</p>`;
                } else {
                    // å–®çµ„æ•¸æ“šçš„è©•ä¼°
                    if (maxRSquared >= 0.95) {
                        analysisText += `<p><strong>çµæœè©•ä¼°ï¼š</strong>æ•¸æ“šé¡¯ç¤ºæ¥µä½³çš„${getCurrentChartTypeName()}é—œä¿‚ (RÂ² = ${maxRSquared.toFixed(3)})ï¼Œæ­¤æ¨¡å‹é«˜åº¦å¯ä¿¡ã€‚</p>`;
                    } else if (maxRSquared >= 0.90) {
                        analysisText += `<p><strong>çµæœè©•ä¼°ï¼š</strong>æ•¸æ“šå‘ˆç¾è‰¯å¥½çš„${getCurrentChartTypeName()}é—œä¿‚ (RÂ² = ${maxRSquared.toFixed(3)})ï¼Œæ­¤æ¨¡å‹å¯æ¥å—ã€‚</p>`;
                    } else if (maxRSquared >= 0.80) {
                        analysisText += `<p><strong>çµæœè©•ä¼°ï¼š</strong>æ•¸æ“šé¡¯ç¤ºä¸­ç­‰ç¨‹åº¦çš„${getCurrentChartTypeName()}é—œä¿‚ (RÂ² = ${maxRSquared.toFixed(3)})ï¼Œå»ºè­°æ”¶é›†æ›´å¤šæ•¸æ“šæˆ–å˜—è©¦å…¶ä»–æ¨¡å‹ã€‚</p>`;
                    } else {
                        analysisText += `<p><strong>çµæœè©•ä¼°ï¼š</strong>ç•¶å‰æ¨¡å‹æ“¬åˆåº¦è¼ƒä½ (RÂ² = ${maxRSquared.toFixed(3)})ï¼Œå»ºè­°å˜—è©¦å…¶ä»–åœ–è¡¨é¡å‹æˆ–æª¢æŸ¥æ•¸æ“šå“è³ªã€‚</p>`;
                    }
                }
                
                // é€šç”¨å»ºè­°
                analysisText += '<p><strong>å»ºè­°ï¼š</strong>';
                if (maxRSquared >= 0.90) {
                    if (allRSquared.length > 1) {
                        analysisText += 'è¡¨ç¾è‰¯å¥½çš„çµ„åˆ¥å¯ç”¨æ–¼åˆ†æå’Œé æ¸¬ã€‚å°æ–¼æ“¬åˆè¼ƒå·®çš„çµ„åˆ¥ï¼Œå¯å˜—è©¦å…¶ä»–åœ–è¡¨é¡å‹ã€‚';
                    } else {
                        analysisText += 'ç•¶å‰æ¨¡å‹é©åˆæ‚¨çš„æ•¸æ“šï¼Œå¯ä»¥ç”¨æ–¼åˆ†æå’Œé æ¸¬ã€‚';
                    }
                } else {
                    analysisText += 'å˜—è©¦åˆ‡æ›åˆ°å…¶ä»–åœ–è¡¨é¡å‹ï¼ˆç·šæ€§åœ–ã€åŠå°æ•¸åœ–ã€é›™å°æ•¸åœ–ï¼‰ï¼Œæ¯”è¼ƒRÂ²å€¼ä¾†æ‰¾å‡ºæœ€ä½³æ“¬åˆã€‚';
                }
                analysisText += '</p>';
                
                // ç§‘å­¸è§£é‡‹æé†’
                analysisText += '<p><strong>é‡è¦æé†’ï¼š</strong>é™¤äº†ç›¸é—œä¿‚æ•¸ï¼Œä¹Ÿè¦è€ƒæ…®ç‰©ç†ç†è«–å’Œå¯¦é©—èƒŒæ™¯ä¾†é¸æ“‡åˆé©çš„æ¨¡å‹ã€‚</p>';
                
                analysisDiv.innerHTML = analysisText;
                formulaContent.appendChild(analysisDiv);
            }
        }
        
        // ç²å–ç•¶å‰åœ–è¡¨é¡å‹çš„ä¸­æ–‡åç¨±
        function getCurrentChartTypeName() {
            switch(chartType) {
                case 'linear': return 'ç·šæ€§';
                case 'semilogx': return 'å°æ•¸';
                case 'semilogy': return 'æŒ‡æ•¸';
                case 'loglog': return 'å†ªæ¬¡';
                default: return 'ç·šæ€§';
            }
        }

        // æ›´æ–°åœ–è¡¨ï¼ˆç”¨æ–¼æ•¸æ“šè¼¸å…¥æ™‚ï¼‰
        function updateChart() {
            generateChart();
        }

        // ä¸‹è¼‰åœ–è¡¨
        function downloadChart() {
            if (chart) {
                const link = document.createElement('a');
                link.download = 'experiment_chart.png';
                link.href = chart.toBase64Image();
                link.click();
            }
        }

        // è™•ç†çª—å£å¤§å°è®ŠåŒ– - ä¿®å¾©ç‰ˆæœ¬
        function handleResize() {
            if (chart && chart.canvas) {
                const canvas = chart.canvas;
                const wrapper = canvas.parentElement;
                
                // æ ¹æ“šè¢å¹•å¤§å°é‡æ–°è¨­å®šå®¹å™¨
                if (window.innerWidth < 480) {
                    wrapper.style.height = '450px';
                    wrapper.style.minHeight = '350px';
                } else if (window.innerWidth < 768) {
                    wrapper.style.height = '500px';
                    wrapper.style.minHeight = '400px';
                } else {
                    wrapper.style.height = '400px';
                    wrapper.style.minHeight = '300px';
                }
                
                chart.resize();
                
                // æª¢æŸ¥å¿…è¦çš„å±¬æ€§æ˜¯å¦å­˜åœ¨
                if (chart.options && chart.options.plugins && chart.options.scales) {
                    // åœ¨æ‰‹æ©Ÿä¸Šé‡æ–°é…ç½®åœ–è¡¨é¸é …
                    if (window.innerWidth < 768) {
                        if (chart.options.plugins.title && chart.options.plugins.title.font) {
                            chart.options.plugins.title.font.size = 12;
                        }
                        if (chart.options.plugins.legend && chart.options.plugins.legend.labels) {
                            if (chart.options.plugins.legend.labels.font) {
                                chart.options.plugins.legend.labels.font.size = 9;
                            }
                            chart.options.plugins.legend.labels.boxWidth = 10;
                            chart.options.plugins.legend.labels.padding = 6;
                        }
                        if (chart.options.scales.x && chart.options.scales.x.title && chart.options.scales.x.title.font) {
                            chart.options.scales.x.title.font.size = 9;
                        }
                        if (chart.options.scales.y && chart.options.scales.y.title && chart.options.scales.y.title.font) {
                            chart.options.scales.y.title.font.size = 9;
                        }
                        if (chart.options.scales.x && chart.options.scales.x.ticks && chart.options.scales.x.ticks.font) {
                            chart.options.scales.x.ticks.font.size = 8;
                        }
                        if (chart.options.scales.y && chart.options.scales.y.ticks && chart.options.scales.y.ticks.font) {
                            chart.options.scales.y.ticks.font.size = 8;
                        }
                        if (chart.options.elements && chart.options.elements.point) {
                            chart.options.elements.point.radius = 3;
                            chart.options.elements.point.hoverRadius = 5;
                        }
                    } else {
                        if (chart.options.plugins.title && chart.options.plugins.title.font) {
                            chart.options.plugins.title.font.size = 18;
                        }
                        if (chart.options.plugins.legend && chart.options.plugins.legend.labels) {
                            if (chart.options.plugins.legend.labels.font) {
                                chart.options.plugins.legend.labels.font.size = 12;
                            }
                            chart.options.plugins.legend.labels.boxWidth = 15;
                            chart.options.plugins.legend.labels.padding = 10;
                        }
                        if (chart.options.scales.x && chart.options.scales.x.title && chart.options.scales.x.title.font) {
                            chart.options.scales.x.title.font.size = 14;
                        }
                        if (chart.options.scales.y && chart.options.scales.y.title && chart.options.scales.y.title.font) {
                            chart.options.scales.y.title.font.size = 14;
                        }
                        if (chart.options.scales.x && chart.options.scales.x.ticks && chart.options.scales.x.ticks.font) {
                            chart.options.scales.x.ticks.font.size = 10;
                        }
                        if (chart.options.scales.y && chart.options.scales.y.ticks && chart.options.scales.y.ticks.font) {
                            chart.options.scales.y.ticks.font.size = 10;
                        }
                        if (chart.options.elements && chart.options.elements.point) {
                            chart.options.elements.point.radius = 8;
                            chart.options.elements.point.hoverRadius = 10;
                        }
                    }
                    
                    chart.update('none');
                }
            }
        }

        // é é¢è¼‰å…¥å®Œæˆå¾Œåˆå§‹åŒ–ä¸¦è‡ªå‹•ä¿®å¾©æ‰€æœ‰æŒ‰éˆ• - é˜²æ­¢é‡è¤‡ç¶å®š
        window.onload = function() {
            init();
            window.addEventListener('resize', handleResize);
            
            // è‡ªå‹•åŸ·è¡Œä¿®å¾©ï¼Œç¢ºä¿æ‰€æœ‰æŒ‰éˆ•æ­£ç¢ºå·¥ä½œ
            setTimeout(function() {
                console.log('è‡ªå‹•åŸ·è¡ŒæŒ‰éˆ•ä¿®å¾©...');
                
                // ä¿®å¾©æ–°å¢æ•¸æ“šé»æŒ‰éˆ•
                const addButton = document.querySelector('button[onclick="addDataPoint()"]');
                if (addButton && !addButton.dataset.fixed) {
                    console.log('ä¿®å¾©æ–°å¢æ•¸æ“šé»æŒ‰éˆ•...');
                    addButton.dataset.fixed = 'true';
                    addButton.removeAttribute('onclick');
                    addButton.addEventListener('click', function() {
                        console.log('=== è§¸ç™¼æ–°å¢æ•¸æ“šé» ===');
                        
                        // ä¿å­˜æ‰€æœ‰ç¾æœ‰çš„Xè»¸æ•¸æ“š
                        const currentXValues = [];
                        for (let i = 0; i < dataPoints; i++) {
                            const input = document.getElementById(`x_${i}`);
                            currentXValues[i] = input ? input.value : '';
                            console.log(`ä¿å­˜ x_${i}:`, currentXValues[i]);
                        }
                        
                        // ä¿å­˜æ‰€æœ‰å¯¦é©—çµ„çš„ç¾æœ‰æ•¸æ“š
                        const currentGroupValues = [];
                        experimentGroups.forEach((group, groupIndex) => {
                            currentGroupValues[groupIndex] = [];
                            for (let i = 0; i < dataPoints; i++) {
                                const input = document.getElementById(`y_${groupIndex}_${i}`);
                                currentGroupValues[groupIndex][i] = input ? input.value : '';
                            }
                        });
                        
                        // å¢åŠ æ•¸æ“šé»æ•¸é‡
                        dataPoints++;
                        console.log('æ–°çš„dataPoints:', dataPoints);
                        
                        // æ›´æ–°å¯¦é©—çµ„æ•¸æ“šçµæ§‹
                        experimentGroups.forEach((group, groupIndex) => {
                            group.data.push('');
                            currentGroupValues[groupIndex].push('');
                        });
                        
                        // æ–°å¢ç©ºç™½Xè»¸å€¼
                        currentXValues.push('');
                        
                        console.log('é‡å»ºè¡¨æ ¼ï¼Œä½¿ç”¨ä¿å­˜çš„æ•¸æ“š:', currentXValues);
                        
                        // å®Œå…¨é‡å»ºè¡¨æ ¼
                        const table = document.getElementById('dataTable');
                        table.innerHTML = '';
                        
                        // å‰µå»ºè¡¨é ­
                        const headerRow = table.insertRow();
                        headerRow.insertCell().innerHTML = '<strong>å¯¦é©—çµ„åˆ—</strong>';
                        for (let i = 0; i < dataPoints; i++) {
                            headerRow.insertCell().innerHTML = `<strong>æ•¸æ“šé» ${i + 1}</strong>`;
                        }
                        
                        // Xè»¸æ•¸å€¼è¡Œ
                        const xRow = table.insertRow();
                        const xHeaderCell = xRow.insertCell();
                        xHeaderCell.innerHTML = `<div class="editable-cell" onclick="startInlineEdit(this, 0, 'variable')">${manipulatedVariableName}</div>`;
                        xHeaderCell.style.cursor = 'pointer';
                        
                        for (let i = 0; i < dataPoints; i++) {
                            const cell = xRow.insertCell();
                            const value = i < currentXValues.length ? currentXValues[i] : '';
                            console.log(`è¨­å®š x_${i} = "${value}"`);
                            cell.innerHTML = `<input type="number" id="x_${i}" name="x_${i}" value="${value}" placeholder="è¼¸å…¥æ•¸å€¼" onchange="updateChart()">`;
                        }
                        
                        // å„å¯¦é©—çµ„è¡Œ
                        experimentGroups.forEach((group, groupIndex) => {
                            const row = table.insertRow();
                            const nameCell = row.insertCell();
                            nameCell.innerHTML = `<div class="editable-cell" onclick="startInlineEdit(this, ${groupIndex}, 'group')">${group.name}</div>`;
                            nameCell.style.backgroundColor = group.color;
                            nameCell.style.color = 'white';
                            nameCell.style.fontWeight = 'bold';
                            nameCell.style.cursor = 'pointer';
                            
                            for (let i = 0; i < dataPoints; i++) {
                                const cell = row.insertCell();
                                const value = (currentGroupValues[groupIndex] && i < currentGroupValues[groupIndex].length) ? currentGroupValues[groupIndex][i] : '';
                                cell.innerHTML = `<input type="number" id="y_${groupIndex}_${i}" name="y_${groupIndex}_${i}" value="${value}" placeholder="è¼¸å…¥æ•¸å€¼" onchange="updateGroupData(${groupIndex}, ${i}, this.value)">`;
                            }
                        });
                        
                        console.log('=== æ–°å¢å®Œæˆ ===');
                        generateChart();
                    });
                    console.log('æ–°å¢æ•¸æ“šé»æŒ‰éˆ•ä¿®å¾©å®Œæˆ');
                }
                
                // ä¿®å¾©åˆªé™¤å¯¦é©—çµ„æŒ‰éˆ•
                const removeButton = document.querySelector('button[onclick="removeDataColumn()"]');
                if (removeButton && !removeButton.dataset.fixed) {
                    console.log('ä¿®å¾©åˆªé™¤å¯¦é©—çµ„æŒ‰éˆ•...');
                    removeButton.dataset.fixed = 'true';
                    removeButton.removeAttribute('onclick');
                    removeButton.addEventListener('click', function() {
                        console.log('=== è§¸ç™¼åˆªé™¤å¯¦é©—çµ„ ===');
                        
                        if (experimentGroups.length > 1) {
                            experimentGroups.pop();
                            renderExperimentGroups();
                            
                            // æ‰‹å‹•ç§»é™¤è¡¨æ ¼ä¸­çš„æœ€å¾Œä¸€è¡Œï¼Œä¿ç•™ç¾æœ‰æ•¸æ“š
                            const table = document.getElementById('dataTable');
                            const rows = table.rows;
                            
                            // æ‰¾åˆ°æœ€å¾Œä¸€å€‹å¯¦é©—çµ„è¡Œä¸¦ç§»é™¤
                            if (rows.length > 2) { // ç¢ºä¿è‡³å°‘æœ‰è¡¨é ­å’ŒXè»¸è¡Œ
                                const lastRowIndex = rows.length - 1;
                                table.deleteRow(lastRowIndex);
                            }
                            
                            generateChart();
                            console.log('=== åˆªé™¤å®Œæˆ ===');
                        }
                    });
                    console.log('åˆªé™¤å¯¦é©—çµ„æŒ‰éˆ•ä¿®å¾©å®Œæˆ');
                }
                
                console.log('æ‰€æœ‰æŒ‰éˆ•ä¿®å¾©å®Œæˆ');
            }, 100);
        };
    </script>
</body>
</html>